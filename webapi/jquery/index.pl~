#!/usr/bin/perl

use strict;
use Data::Dumper;
use JSON::XS;
use lib "/httpd/modules";
require ZOOVY;
require PAGE::JQUERY;
require DOMAIN::TOOLS;

$ENV{'REQUEST_METHOD'} =~ tr/a-z/A-Z/;

## NOTE: this code is mirrored in SITE::Vstore
print "X-XSS-Protection: 0\n";
print "Access-Control-Allow-Origin: *\n";
print "Access-Control-Allow-Methods: POST, GET, OPTIONS\n";
print "Access-Control-Max-Age: 1000\n";
## NOTE: Access-Control-Allow-Headers does NOT work with * you must specify something (ex: Content-Type)
print "Access-Control-Allow-Headers: Content-Type\n";
print "Vary: Accept-Encoding\n";
if ($ENV{'REQUEST_METHOD'} eq 'OPTIONS') {
	print STDERR "ACKNOWLEDGED OPTIONS HEADER\n";
	print "Content-Length: 0\n";
	print "Keep-Alive: timeout=2, max=100\n";
	print "Connection: Keep-Alive\n";
	print "Content-type: text/plain\n\n";
	exit;
	}



$SITE::CART = undef;
$SITE::merchant_id = '';
$SITE::SREF = {};
## lookup domain, and from that we can get everything else.

# &ZOOVY::init(); can't run zoovy init.


##
## PHASE1: parse cookies, and input data. 
##
# print STDERR Dumper(\%ENV);

## Read input
my $buffer = undef;
if ($ENV{'REQUEST_METHOD'} eq "GET") {
	$buffer = $ENV{'QUERY_STRING'};
	}
elsif ($ENV{'REQUEST_METHOD'} eq "POST") {
	read(STDIN, $buffer, $ENV{'CONTENT_LENGTH'});
	}

## NOW we need to decide 
# print STDERR 'REQUEST: '.Dumper(\%ENV,{$ENV{'CONTENT_TYPE'}=>$buffer});
print STDERR "BUFFER: $buffer\n";

# Split information into name/value pairs
my $VARS = undef;
if ($buffer eq '') {
	warn "No content received\n";
	}
elsif ($ENV{'CONTENT_TYPE'} =~ /^(text|application)\/json/) {
	## text/json
	## application/json
	$VARS = JSON::XS::decode_json($buffer);
	}
else {
	my @pairs = split(/&/, $buffer);
	foreach my $pair (@pairs) {
		my ($name, $value) = split(/=/, $pair);
		$value =~ tr/+/ /;
		$value =~ s/%(..)/pack("C", hex($1))/eg;
		$VARS->{$name} = $value;
		}
	}
print STDERR 'VARS: '.Dumper($VARS);

$ZOOVY::cookies = {};
if ($ENV{'HTTP_COOKIE'} ne '') {
	## we got some cookies, lets parse 'em.
	#__utma=98299796.877293812.1256064081.1330024164.1330026365.244; __utmv=98299796.|1=Tier=AA=1; __utmz=98299796.1329264247.238.34.utmcsr=blogger.com|utmccn=(referral)|utmcmd=referral|utmcct=/profile/05925940776420361689; ZOOVY_LEAD=%7C%7C; __utmc=98299796; session_id=; zjsid=**18aUG5RqFiOKhI2lu4vwpITv7?USERNAME=brian|LUSER=ADMIN|X=HGwktX5jzP1I8qKpwY79zrAFV; __utmb=98299796.1.10.1330026365
	foreach my $line (split(/;[\s]*/,$ENV{'HTTP_COOKIE'})) {
		my ($k,$v) = split(/=/,$line,2);
		$ZOOVY::cookies->{$k} = $v;
		if (not defined $VARS->{"_$k"}) { $VARS->{"_$k"} = $v; }
		}
	}



if ($VARS->{'_zjsid'} eq '') {
	## gosh, hopefully it's a login call.
	}
elsif (substr($VARS->{'_zjsid'},0,2) eq '**') {
	## admin session.
	require AUTH;
	my ($result) = AUTH::fast_validate_session($VARS->{'_zjsid'});

	# print STDERR 'AUTHENTICATION: '.Dumper($result,$VARS->{'_zjsid'});

	$SITE::merchant_id = $result->{'USERNAME'};
	$SITE::SREF->{'+sdomain'} = $result->{'DOMAIN'};
	$SITE::SREF->{'+ssl_domain'} = $result->{'DOMAIN'};
	$SITE::SREF->{'+prt'} = $result->{'PRT'};
	$SITE::SREF->{'_NS'} = $result->{'PROFILE'};	

	my ($globalref) = &ZWEBSITE::fetch_globalref($SITE::merchant_id,$SITE::SREF->{'+cache'});
	$SITE::SREF->{'%GREF'} = $globalref;
	}
elsif ($ENV{'REQUEST_URI'} =~ /index\.cgi\/(.*?)$/) {
	$SITE::SREF->{'+sdomain'} = $1;
	($SITE::merchant_id,$SITE::SREF->{'+ssl_domain'},$SITE::SREF->{'+prt'},$SITE::SREF->{'_NS'}) = &DOMAIN::TOOLS::fast_resolve_domain_to_user($SITE::SREF->{'+sdomain'});

	my ($globalref) = &ZWEBSITE::fetch_globalref($SITE::merchant_id,$SITE::SREF->{'+cache'});
	$SITE::SREF->{'%GREF'} = $globalref;
	}
elsif (1) {
	## not sure what would break if I take this out, I think it was used before login was moved to the top.
	}
else {
	print "Content-type: text/plain\n\n";
	print "could not determine credentials\n";
	exit;
	}

if ((defined $SITE::merchant_id) && ($SITE::merchant_id ne '')) {
	my ($udbh) = &DBINFO::db_user_connect($SITE::merchant_id);
	my ($R,$cmdlines) = PAGE::JQUERY::handle($ENV{'REQUEST_URI'},$VARS);
	my ($utf8_encoded_json_text) = JSON::XS->new->utf8->allow_blessed(1)->convert_blessed(1)->encode($R);

	print STDERR 'PAGE::JQUERY::handle response: '.Dumper($R,$cmdlines,$utf8_encoded_json_text);
	
	if (defined $SITE::CART) {
		$SITE::CART->save();
		}
	&DBINFO::db_user_close();
	}

print "Content-type: text/json\n";
print "Content-Length: ".length($utf8_encoded_json_text)."\n";
print "\n";
print $utf8_encoded_json_text;


1;
