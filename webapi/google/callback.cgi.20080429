#!/usr/bin/perl

use strict;
use Google::Checkout::General::GCO;
use Google::Checkout::General::MerchantCalculationCallback;
use Google::Checkout::General::MerchantCalculationResults;
use Google::Checkout::General::MerchantCalculationResult;
use Google::Checkout::XML::Constants;
use Google::Checkout::General::Util qw/is_gco_error/;
use Google::Checkout::Notification::Factory qw/get_notification_object/;
use Data::Dumper;

use lib "/httpd/modules";
require DBINFO;
require ZOOVY;
require CART;
require ZTOOLKIT;
require ZPAY::GOOGLE;

%::DEBUGUSER = ();
$::DEBUGUSER{'theh2oguru'}++;

$|++;

# TYPES OF COMMANDS:
#       Financial commands enable you to modify an order's
# financial-order-state, which identifies the stage of the payment process
# where the order is located. The Order Processing API defines four financial
# commands:
# 
#       <charge-order>
#       <refund-order>
#       <cancel-order>
#       <authorize-order>
# 
#       The <charge-order> and <refund-order> commands also instruct Google
# Checkout to debit or credit the customer for a specified amount.
#     *
# 
#       Fulfillment commands enable you to modify an order's
# fulfillment-order-state, which identifies the stage of the fulfillment
# process where the order is located. The Order Processing API defines five
# fulfillment commands:
# 
#       <process-order>
#       <add-merchant-order-number>
#       <deliver-order>
#       <add-tracking-data>
#       <send-buyer-message>
# 
#       Fulfillment commands enable you to communicate the status of an order
# to your customer.
#     *
# 
#       Archiving commands enable you to manage the list of orders in your
# Merchant Center inbox. The Order Processing API defines two archiving
# commands.
# 
#       <archive-order>
#       <unarchive-order>
# 
#       Archiving commands do not have any impact on an order's status or on
# the order information that is communicated to the customer.
# 



##
## ORDER STATES
##
# REVIEWING  (charge-order)
# REVIEWING is the default financial state for all new orders. Upon receiving
# a new order, Google reviews the order to confirm that it is chargeable.
# After determining that the order is chargeable, Google will update the
# financial order state to CHARGEABLE.
# 
# Note: You may issue a charge-order command while an order is still in the
# REVIEWING state. However, please be aware of the following processing rules
# for that request.
# 
#       Google will not actually charge the customer until Google has updated
# the order state to CHARGEABLE.
#
#       If you issue a second charge-order command while the order is still in
# the REVIEWING state, you will receive an error indicating that you have
# requested an invalid state transition.
# 
#       You should not consider the order to be charged until you receive an
# order-state-change-notification indicating that the order's financial state
# has been changed to CHARGED.
# 
# CHARGEABLE 	(authorize-order,cancel-order,charge-order)
# 
# The CHARGEABLE state indicates that you may charge the customer for an order
# by issuing a charge-order command. You may also cancel the order by issuing
# a cancel-order command.
# CHARGING 	None 	
# 
# The CHARGING state indicates that Google is in the process of charging the
# customer. Any actions taken on an order in this state will be invalid. Once
# the charge has been completed, Google will update the financial order state
# to CHARGED, even if you only charged the customer for part of the order.
# However, in the case of a partial charge, the remaining balance on the order
# will still be chargeable even though the financial order state is CHARGED
# rather than CHARGEABLE.
#
# CHARGED 	(authorize-order,charge-order,refund-order)
# 
# The CHARGED state indicates that you have fully or partially charged the
# customer for an order. If you have partially charged the customer, the order
# will still be chargeable until you have charged the customer for the full
# order amount.
# 
# Note: If you partially charge an order, you may want to use the
# <send-buyer-message> command to inform the customer of the partial charge.
# For partially charged orders, the buyer's account page will display the
# amount that has been charged.
# PAYMENT_DECLINED 	cancel-order 	
# 
# The PAYMENT_DECLINED state indicates that Google's effort to authorize or
# charge the customer's credit card failed. If this happens, Google will email
# the customer to request a new credit card. The customer will have 72 hours
# to submit a new card.
#
#       If the customer submits a new credit card for an order that previously
# failed authorization, Google will send you an
# order-state-change-notification indicating that the order's financial update
# status has been updated to CHARGEABLE.
#
#       If the customer submits a new credit card for an order that previously
# failed to charge, Google will charge the credit card and send you an
# order-state-change-notification indicating that the order's financial update
# status has been updated to CHARGED.
# 
# CANCELLED 	None 	
# 
# The CANCELLED state indicates that the merchant issued a cancel-order
# command, canceling the order. Once an order is canceled, you may no longer
# update the order's financial order state.
# 
# You may cancel an order that is in either the CHARGEABLE or the
# PAYMENT_DECLINED financial state. You may not cancel an order that has
# already been charged until you have already issued a refund for the offer.
# CANCELLED_BY_GOOGLE 	None 	
# 
# The CANCELLED_BY_GOOGLE state indicates that Google canceled an order.
# Google may cancel an order if the credit card authorization fails and the
# customer does not provide a new credit card within 72 hours. Google will
# send an order-state-change-notification indicating that the order was
# canceled, and the reason tag in the notification will explain why Google
# canceled the order.
# 

##
## FULFILLMENT STATES
## 
# Fulfillment State  	Action that Places an Order in this State
# Description
# NEW 	Buyer submits new order. 	
# 
# NEW is the default fulfillment state for all new orders.
# PROCESSING 	process-order 	
# 
# The PROCESSING fulfillment state indicates that you are in the process of
# filling the customer's order. You can change the fulfillment state for an
# order to PROCESSING by issuing a process-order order processing command.
# DELIVERED 	deliver-order 	
# 
# The DELIVERED fulfillment state indicates that you have shipped the order
# and it has been delivered. You can change the fulfillment state for an order
# to DELIVERED by issuing a deliver-order order processing command.
# WILL_NOT_DELIVER 	cancel-order 	
# 
# The WILL_NOT_DELIVER fulfillment state indicates that you will not ship the
# items to the customer. If you cancel an order by issuing a cancel-order
# request, or if Google cancels an order, the order's fulfillment state will
# update to WILL_NOT_DELIVER.
# 

my ($USERNAME,$VERSION,$xml) = (undef,undef,undef,undef,undef);

##
##
##
my $dbh = &DBINFO::db_zoovy_connect();
my $dbID = 0;

my %params = ();
if ($ENV{'REQUEST_METHOD'} eq 'POST') {
	$/ = undef; $xml = <STDIN>; $/ = "\n";
	$xml =~ s/[\r]+//gs;

	&DBINFO::insert($dbh,'GOOGLE_NOTIFICATIONS',{ID=>0,'*CREATED'=>'now()',DATA=>$xml,PROCESSED_GMT=>0,REQUEST_URI=>$ENV{'REQUEST_URI'}},debug=>1);
	my $pstmt = "select last_insert_id()";
	my $sth = $dbh->prepare($pstmt);
	$sth->execute();
	($dbID) = $sth->fetchrow();
	$sth->finish();	
	}
else {
	## hmm.. not a post?

	foreach my $arg (@ARGV) {
		if ($arg !~ /=/) { die("Bad argument - [$arg] plz check syntax in file."); }
		my ($k,$v) = split(/=/,$arg);
		$params{$k} = $v;
		}
	
	if (defined $params{'REPLAY'}) {
		my $pstmt = "select * from GOOGLE_NOTIFICATIONS where ID=".int($params{'REPLAY'});
		# print STDERR $pstmt."\n";
		my $sth = $dbh->prepare($pstmt);
		$sth->execute();
		my ($hashref) = $sth->fetchrow_hashref();
		$sth->finish();
		$dbID = $hashref->{'ID'};

		$ENV{'REQUEST_URI'} = $hashref->{'REQUEST_URI'};
		$xml = $hashref->{'DATA'};
		# print STDERR "SETTING URI [$ENV{'REQUEST_URI'}]\n";
		}

  }

my $PRT = 0;
# print STDERR "$ENV{'REQUEST_URI'}\n";
if ($ENV{'REQUEST_URI'} =~ /\/webapi\/google\/callback\.cgi\/v=([\d]+)\/u\=([a-zA-Z0-9]+)\/c=([a-zA-z0-9]+)\/prt=([\d]+)$/) {
	($VERSION,$USERNAME,my $CARTID,$PRT) = ($1,$2,$3,$4);
	}
elsif ($ENV{'REQUEST_URI'} =~ /\/webapi\/google\/callback\.cgi\/v=([\d]+)\/u\=([a-zA-Z0-9]+)\/c=([a-zA-z0-9]+)\/$/) {
	($VERSION,$USERNAME,my $CARTID) = ($1,$2,$3);
	}
# https://webapi.zoovy.com/webapi/google/callback.cgi/v=1/u=theh2oguru/prt=0
elsif ($ENV{'REQUEST_URI'} =~ /\/webapi\/google\/callback\.cgi\/v=1\/u\=([a-zA-Z0-9]+)\/prt=([\d]+)$/) {
	print STDERR "USER[$USERNAME] PRT[$PRT]\n";
	($USERNAME,$PRT) = ($1,$2);
	}
elsif ($ENV{'REQUEST_URI'} =~ /\/webapi\/google\/callback\.cgi\/v=1\/u\=([a-zA-Z0-9]+)$/) {
	
	($USERNAME) = ($1);
	}
elsif ($ENV{'REQUEST_URI'} =~ /\/webapi\/google\/callback\.cgi/) {
	## unspecified username/parameter on command line.
	($VERSION,$USERNAME,my $CARTID) = (1,undef,undef);
#	$xml =~ s/[\r]+//gs;
	}
elsif ($ENV{'REQUEST_URI'} =~ /\/webapi\/google\/notify\.cgi/) {
	## unspecified username/parameter on command line.
	($VERSION,$USERNAME,my $CARTID) = (1,undef,undef);
#	$xml =~ s/[\r]+//gs;
	}
else {
	die("Nothing passed on the REQUEST_URI");
  }



##
## GN = Google Notification Object
##
my $GN = get_notification_object(xml => $xml);
die $GN if is_gco_error $GN;


print STDERR "TYPE: ".$GN->type."\n";



##
## UPDATE OUR DATABASE WITH CALL DETAILS.
##
if ((defined $GN) && ($dbID>0)) {

	my $qtCALLTYPE = $dbh->quote( $GN->type );
	my $qtSERIAL = $dbh->quote( $GN->get_serial_number );
	my $qtORDERNUM = $dbh->quote( $GN->get_order_number );
	## get_serial_number
	## get_order_number

	my $pstmt = "update GOOGLE_NOTIFICATIONS set CALL_TYPE=$qtCALLTYPE,GOOGLE_SERIAL=$qtSERIAL,GOOGLE_INVNUM=$qtORDERNUM where ID=".int($dbID);
	$dbh->do($pstmt);

	}



##
## IF WE GOT AN ORDER, LETS DO A QUICK CHECK
##
if (($GN->type eq 'new-order-notification') && (!defined $params{'REPLAY'})) {
	## DO A QUICK DUPLICATE ORDER CHECK
	my ($USER,$ORDERID) = &ZPAY::GOOGLE::resolve_orderid($GN->get_order_number());
	if ($USER ne '') { $USERNAME = $USER; }
	

	if (($USERNAME ne '') && ($ORDERID ne '')) {
		## WE HAVE A DUPLICATE!
		warn "Found duplicate order-id $ORDERID\n";
		my $webdbref = &ZWEBSITE::fetch_website_dbref($USERNAME,$PRT);
		my $gco = &ZPAY::GOOGLE::buildGCO($USERNAME,$webdbref);
		$gco->send_notification_response();
		$GN = undef;
		}
	}



##
##
##
if ( (defined $GN) && ($GN->type eq 'charge-amount-notification') ) {
	# Google Checkout sends a <charge-amount-notification> after successfully
	# charging a customer for an order. Google Checkout will attempt to charge a
	# customer if you send a <charge-order> order processing command requesting a
	# charge. You can also instruct Google to automatically charge customers when
	# they submit new orders. To set this preference, log in to your Checkout
	# account and click the Settings tab. Then click the Preferences link in the
	# menu on the left side of the page. Finally, select the option to
	# "Automatically authorize and charge the buyer's credit card."
	# 
	# Note: You should not assume that Google has charged your customer until you
	# have received the <charge-amount-notification>. This notification is
	# typically sent within seconds of the corresponding <charge-order> request.
	my ($USER,$ORDERID) = &ZPAY::GOOGLE::resolve_orderid( $GN->get_order_number() );
	if ($USER ne '') { $USERNAME = $USER; }

	if (($USERNAME ne '') && ($ORDERID ne '')) {
		require ORDER;
		my ($o) = ORDER->new($USERNAME,$ORDERID);

		#
		# <?xml version="1.0" encoding="UTF-8"?>
		# <charge-amount-notification xmlns="http://checkout.google.com/schema/2" serial-number="767650915669533-00008-2">
		#   <timestamp>2007-08-19T23:03:21.000Z</timestamp>
		#   <google-order-number>767650915669533</google-order-number>
		#   <latest-charge-amount currency="USD">7.93</latest-charge-amount>
		#   <total-charge-amount currency="USD">7.93</total-charge-amount>
		# </charge-amount-notification>
		#

		my $order_total = sprintf("%.2f",$o->get_attrib('order_total'));

		if ($order_total == $GN->get_total_charge_amount) {
			$o->event(sprintf("GC ChargeNotification Latest:%.2f Total:%.2f",
				$GN->get_latest_charge_amount,
				$GN->get_total_charge_amount
				),time(),1+2+4,'*google');
			$o->set_payment_status('011','*google',[],0,1);
			}
		elsif ((defined $::DEBUGUSER{$USERNAME}) || (1)) {
			$o->event(sprintf("GC ChargeNotification ERROR Total:%.2f (does not match order total: %.2f)",
				$GN->get_total_charge_amount,
				$order_total
				),time(),1+2+4+8,'*google');
			}

		$o->save();
		#
		#		print <<__CHARGE_AMOUNT__;
		# #-------------------------#
		# #     Charge amount       #
		# #-------------------------#
		#  Latest charge amount: @{[$charge_amount->get_latest_charge_amount]}
		#  Total charge amount:  @{[$charge_amount->get_total_charge_amount]}
		#
		#
		# __CHARGE_AMOUNT__
		#
		my $webdbref = &ZWEBSITE::fetch_website_dbref($USERNAME,$PRT);
		my $gco = &ZPAY::GOOGLE::buildGCO($USERNAME,$webdbref);
		$gco->send_notification_response();
		$GN = undef;
		}
	else {
		}

	}


##
##
if ( (defined $GN) && ($GN->type eq 'refund-amount-notification') ) {
	# Google Checkout sends a <refund-amount-notification> after successfully
	# executing a <refund-order> order processing command. You should not assume
	# that Google has granted a refund until you receive the
	# <refund-amount-notification>. This notification is typically sent within
	# seconds of the corresponding <refund-order> request.

	my ($USER,$ORDERID) = &ZPAY::GOOGLE::resolve_orderid( $GN->get_order_number() );
	if ($USER ne '') { $USERNAME = $USER; }

	if (($USERNAME ne '') && ($ORDERID ne '')) {
		require ORDER;
		my ($o) = ORDER->new($USERNAME,$ORDERID);

		$o->event(sprintf("GC RefundNotification Latest:%.2f Total: %.2f",
			$GN->get_latest_refund_amount,
			$GN->get_total_refund_amount
			),time(),1+2+4,'*google');

		$o->set_payment_status(311,'*google',[],0,1);
		$o->save();			

		my $webdbref = &ZWEBSITE::fetch_website_dbref($USERNAME,$PRT);
		my $gco = &ZPAY::GOOGLE::buildGCO($USERNAME,$webdbref);
		$gco->send_notification_response();

		$GN = undef;
		}

	}

##
##
#if ( (defined $GN) && ($GN->type eq 'cancel-order-notification') ) {
#	# Google Checkout sends a <refund-amount-notification> after successfully
#	# executing a <refund-order> order processing command. You should not assume
#	# that Google has granted a refund until you receive the
#	# <refund-amount-notification>. This notification is typically sent within
#	# seconds of the corresponding <refund-order> request.
#
#	my ($USERNAME,$ORDERID) = &ZPAY::GOOGLE::resolve_orderid( $GN->get_order_number() );
#	if (($USERNAME ne '') && ($ORDERID ne '')) {
#		require ORDER;
#		my ($o) = ORDER->new($USERNAME,$ORDERID);
#
#		$o->event(sprintf("GC Cancel Order Latest:%.2f Total: %.2f",
#			$GN->get_latest_refund_amount,
#			$GN->get_total_refund_amount
#			),time(),1+2+4,'*google');
#
#		$o->set_payment_status(311,'*google',[],0,1);
#		$o->save();			
#
#		my $gco = &ZPAY::GOOGLE::buildGCO($USERNAME);
#		$gco->send_notification_response();
#
#		$GN = undef;
#		}
#
#	}

##
##
##
if ( (defined $GN) && ($GN->type eq 'chargeback-amount-notification') ) {
	# Google Checkout sends a <chargeback-amount-notification>
	# when a customer initiates a chargeback against the order and Google approves
	# the chargeback.

	my ($USER,$ORDERID) = &ZPAY::GOOGLE::resolve_orderid( $GN->get_order_number() );
	if ($USER ne '') { $USERNAME = $USER; }

	if (($USERNAME ne '') && ($ORDERID ne '')) {
		require ORDER;
		my ($o) = ORDER->new($USERNAME,$ORDERID);

		$o->event(sprintf("GC Chargeback Latest:%.2f Total: %.2f",
			$GN->get_latest_chargeback_amount,
			$GN->get_total_chargeback_amount
			),time(),1+2+4,'*google');

		$o->set_payment_status(311,'*google',[],0,1);
		$o->save();			

		my $webdbref = &ZWEBSITE::fetch_website_dbref($USERNAME,$PRT);
		my $gco = &ZPAY::GOOGLE::buildGCO($USERNAME,$webdbref);
		$gco->send_notification_response();

		$GN = undef;
		}

	}


##
##
##
#if ( (defined $GN) && ($GN->type eq 'authorization-amount-notification') ) {
#	# Google Checkout sends an <authorization-amount-notification> in response to
#	# a successful request for an explicit credit card reauthorization. You can
#	# also modify your Checkout API request to instruct Google Checkout to send an
#	# <authorization-amount-notification> after a customer submits a new order and
#	# Google Checkout authorizes the customer's credit card.
#--
#-- User normally gets the XML from Checkout
#--
#my $xml = $ARGV[0] || "xml/charge_amount_notification.xml";
#
#my $charge_amount = Google::Checkout::Notification::ChargeAmount->new(xml => $xml);
#die $charge_amount if is_gco_error $charge_amount;
#
#print <<__CHARGE_AMOUNT__;
##-------------------------#
##     Charge amount       #
##-------------------------#
#Latest charge amount: @{[$charge_amount->get_latest_charge_amount]}
#Total charge amount:  @{[$charge_amount->get_total_charge_amount]}
#
#
#__CHARGE_AMOUNT__
#
#	}

if ( (defined $GN) && ($GN->type eq 'order-state-change-notification') ) {
	# Google sends an order state change notification to notify you that an
	# order's financial status or its fulfillment status has changed. The
	# notification identifies the new financial and fulfillment statuses for the
	# order as well as the previous statuses for that order.
	# 
	# These status changes can be triggered by Order Processing API commands that
	# you send to Google Checkout. For example, if you send Google Checkout a
	# <cancel-order> request, Google will respond through the Notification API to
	# inform you that it changed the order's status to CANCELLED.
	# 
	# Note: Before you ship the items in an order, you should ensure that you have
	# already received the new order notification for the order, the risk
	# information notification for the order and an order state change
	# notification informing you that the order's financial state has been updated
	# to CHARGEABLE.

	my ($o);

	my ($USER,$ORDERID) = &ZPAY::GOOGLE::resolve_orderid( $GN->get_order_number() );
	if ($USER ne '') { $USERNAME = $USER; }

	if (($USERNAME ne '') && ($ORDERID ne '')) {
		require ORDER;
		($o, my $err) = ORDER->new($USERNAME,$ORDERID);
		
		if ((not defined $o) || (ref($o) ne 'ORDER')) {
			warn "Order was not defined - err is: $err";
			$ORDERID = '';
			}
		}


	if (($USERNAME eq '') || ($ORDERID eq '')) {
		open F, ">/tmp/google.order-state-change-notification.".time();
		use Data::Dumper; print F Dumper($xml,$USER,$ORDERID);
		close F;

		my $webdbref = &ZWEBSITE::fetch_website_dbref($USERNAME,$PRT);
		my ($gco) = &ZPAY::GOOGLE::buildGCO($USERNAME,$webdbref,0);
		if (not defined $gco) {
			use Data::Dumper;
			print STDERR Dumper("Invalid GCO Object",$gco);
			}
		$gco->send_notification_response();

		}
	else {
		## SUCCESS!
		
		$o->event(sprintf("GC OrderState: %s/%s - %s (was %s/%s)",
			$GN->get_new_fulfillment_order_state,
			$GN->get_new_financial_order_state,
			$GN->get_reason,
			$GN->get_previous_fulfillment_order_state,
			$GN->get_previous_financial_order_state
			),time(),1+2+4,'*google');
		

#<order-state-change-notification xmlns="http://checkout.google.com/schema/2" serial-number="433090901980728-00008-1">
#  <timestamp>2007-08-21T02:10:11.000Z</timestamp>
#  <google-order-number>433090901980728</google-order-number>
#  <new-fulfillment-order-state>WILL_NOT_DELIVER</new-fulfillment-order-state>
#  <new-financial-order-state>CANCELLED</new-financial-order-state>
#  <previous-fulfillment-order-state>NEW</previous-fulfillment-order-state>
#  <previous-financial-order-state>CHARGEABLE</previous-financial-order-state>
#</order-state-change-notification>


		if ($GN->get_new_financial_order_state eq 'CHARGEABLE') {
			$o->set_payment_status(199,'*google',[],0,1);
			}
		elsif ($GN->get_new_financial_order_state eq 'CHARGED') {
			$o->set_payment_status('011','*google',[],0,1);
			}
		elsif ($GN->get_new_financial_order_state eq 'CHARGING') {
			$o->set_payment_status('511','*google',[],0,1);
			}
		elsif ($GN->get_new_financial_order_state eq 'CANCELLED') {
			$o->set_payment_status('311','*google',[],0,1);			
			}
		else {
			$o->set_payment_status('411','*google',["Unknown Financial State [".($GN->get_new_financial_order_state)."] Encountered!"],0,1);			
			}
		#elsif ($GN->get_new_financial_order_state eq 'CHARGEABLE') {
		#	$o->set_payment_status(199);
		#	}

		# print Dumper($o);

		my $webdbref = &ZWEBSITE::fetch_website_dbref($USERNAME,$PRT);
		my ($gco) = &ZPAY::GOOGLE::buildGCO($USERNAME,$webdbref,0);
		if (not defined $gco) {
			use Data::Dumper;
			print STDERR Dumper("Invalid GCO Object",$gco);
			}
		$gco->send_notification_response();

#		if ($ORDERID ne '') {
#			## Inform Google of the order #
#			my $gco = &ZPAY::GOOGLE::buildGCO($USERNAME);
#			require Google::Checkout::Command::AddMerchantOrderNumber;		
#			my $add_merchant_order = Google::Checkout::Command::AddMerchantOrderNumber->new(
#                        order_number          => $GN->get_order_number,
#                        merchant_order_number => $ORDERID);
#			my $run_diagnose = 0;
#			my $response = $gco->command($add_merchant_order, $run_diagnose);
#			$o->event("GC AddMerchantOrderNumber: ".$response,time(),1+2+4,'*google');
#			}
		$o->save();

		$GN = undef;
		}

#	print <<__ORDER_STATE_CHANGE__;
#GOID: $GOID
##-------------------------#
##   Order state change    #
##-------------------------#
#New fulfillment state: $new_ful_state
#old fulfillment state: $old_ful_state
#New financial state:   $new_fin_state
#Old financial state:   $old_fin_state
#Reason:                $reason
#
#__ORDER_STATE_CHANGE__

	}



if ( (defined $GN) && ($GN->type eq 'risk-information-notification') ) {
	# Google Checkout sends a risk information notification to provide financial
	# information that helps you to ensure that an order is not fraudulent. A
	# risk-information-notification includes the customer's billing address, a
	# partial credit card number and other values to help you verify that an order
	# is not fraudulent. Google Checkout sends a risk-information-notification
	# message after completing its risk analysis on a new order.

	# Note: Before shipping the items in the order, you should wait until you have
	# also received the new order notification for the order and the order state
	# change notification informing you that the order's financial state has been
	# updated to CHARGEABLE.

	my ($USER, $ORDERID) = &ZPAY::GOOGLE::resolve_orderid( $GN->get_order_number() );
	if ($USER ne '') { $USERNAME = $USER; }

	if (($USERNAME ne '') && ($ORDERID ne '')) {
		require ORDER;
		my ($o) = ORDER->new($USERNAME,$ORDERID);
		# print STDERR "USERNAME: $USERNAME ORDERID: $ORDERID\n";

		$o->event(sprintf("GC Risk Info AVS:%s CVN:%s PROTECTED:%s",
			$GN->get_avs_response,
			$GN->get_cvn_response,
			(($GN->eligible_for_protection)?'Y':'N')
			),time(),1+2+4,'*google');
		
		if (not $GN->eligible_for_protection) {
			$o->set_attrib('google_protection',$GN->eligible_for_protection);
			}

		# Returns the partial credit card number.
		$o->set_attrib('cc_number',$GN->get_partial_cc_number());

		# Returns the buyer Google Checkout account age in days.
		$o->set_attrib('google_account_age',$GN->get_buyer_account_age());

		# Returns the buyer IP address.
		$o->set_attrib('ip_address',$GN->get_buyer_ip_address());

		#if ($GN->get_new_financial_order_state eq 'CHARGEABLE') {
		#	$o->set_payment_status(199);
		#	}
		#elsif ($GN->get_new_financial_order_state eq 'CHARGEABLE') {
		#	$o->set_payment_status(199);
		#	}

		# print Dumper($o);
		$o->save();

		my $webdbref = &ZWEBSITE::fetch_website_dbref($USERNAME,$PRT);
		my $gco = &ZPAY::GOOGLE::buildGCO($USERNAME,$webdbref);
		$gco->send_notification_response();

		$GN = undef;
		}
	else {
		## ERROR! (now handled by generic error handler)
		}

#       get_buyer_info WHICH_DATA
#           Returns buyer information. WHICH_DATA can be "Google::Checkout::XML::Constants::BUYER_CONTACT_NAME", "Google::Check-
#           out::XML::Constants::BUYER_COMPANY_NAME", "Google::Checkout::XML::Constants::BUYER_EMAIL", "Google::Checkout::XML::Con-
#           stants::BUYER_PHONE", "Google::Checkout::XML::Constants::BUYER_FAX", "Google::Checkout::XML::Constants::BUYER_ADDRESS1",
#           "Google::Checkout::XML::Constants::BUYER_ADDRESS2", "Google::Checkout::XML::Constants::BUYER_CITY", "Google::Check-
#           out::XML::Constants::BUYER_REGION", "Google::Checkout::XML::Constants::BUYER_POSTAL_CODE", "Google::Checkout::XML::Con-
#           stants::BUYER_COUNTRY_CODE".

	}




if ( (defined $GN) && ($GN->type eq 'new-order-notification') ) {
	## Apparently customers can create a random payment request .. thanks google!
	
	if ($GN->get_merchant_private_data eq '') {
		## Shit.. lets be done!
		# print STDERR "USERNAME: $USERNAME\n";
		warn "Encountered an unknown payment - ignoring";
		my $gco = &ZPAY::GOOGLE::buildGCO($USERNAME);
		$gco->send_notification_response();
		$GN = undef;
		}

	}



if ( (defined $GN) && ($GN->type eq 'new-order-notification') ) {

	# Google sends a new order notification when a buyer places an order through
	# Google Checkout. A new-order-notification message contains a list of the
	# items in the order, the order total, the taxes and shipping charges assessed
	# for the order and a list of any coupons or gift certificates applied to the
	# order total. The new order notification also identifies the shipping method
	# selected for the order, the shipping address for the order and the billing
	# address for the order																						.

	# The <order-adjustment> element in a new order notification specifies the
	# shipping method for the order as well as the shipping costs, taxes and
	# discounts that were applied to the order. If you have implemented the
	# Merchant Calculations API, the <merchant-calculation-successful> element
	# will indicate whether Google successfully received a
	# <merchant-calculation-results> from your calculations service					.

	# Your application needs to return an HTTP 200 response code after receiving
	# and successfully processing a new order notification. Your application needs
	# to return either a 4xx or 5xx HTTP response code (500, 501, etc.) if it is
	# unable to process the notification						.

	# Before shipping the items in an order, you should wait until you have also
	# received the risk information notification for that order as well as the
	# order state change notification informing you that the order's financial
	# state has been updated to CHARGEABLE	.

	my $cart = &ZPAY::GOOGLE::decodeCart($GN->get_merchant_private_data);
	my $USERNAME = $cart->{'username'};
	my $CARTID = $cart->{'id'};


	#--
	#-- First got all the items
	#--
	my $items = $GN->get_items();

	for my $item (@$items) {
		my $private = $item->get_private;

#  print <<__ONE_ITEM__;
#Item:
#ID:           @{[$item->get_merchant_item_id]}
#Name:         @{[$item->get_name]}
#Description:  @{[$item->get_description]}
#Price:        @{[$item->get_price]}
#Quantity:     @{[$item->get_quantity]}
#Private data: @$private
#Tax table:    @{[$item->get_tax_table_selector]}
#
#__ONE_ITEM__
		}


	#my $shipname = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_SHIPPING,
   #   Google::Checkout::XML::Constants::BUYER_CONTACT_NAME,2);
	#my $billname = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_BILLING,
   #   Google::Checkout::XML::Constants::BUYER_CONTACT_NAME,2);
#
#	$shipname =~ s/^[\s]+//gs;
#	$shipname =~ s/[\s]+$//gs;
#	$billname =~ s/^[\s]+//gs;
#	$billname =~ s/[\s]+$//gs;
#
#	my ($smi,$bmi) = ('','');
#	my ($sfirstname,$slastname) = split(/[\s]+/,$shipname,2);
#	if ($slastname =~ /^([A-Za-z]+)[\.]? (.*)$/) {
#		## middle initial?
#		($slastname,$smi) = ($2,$1);
#		}
#
#	my ($bfirstname,$blastname) = split(/[\s]+/,$billname,2);
#	if ($blastname =~ /^([A-Za-z]+)[\.]? (.*)$/) {
#		## middle initial?
#		($blastname,$bmi) = ($2,$1);
#		}
	
	
	tie my %cart, 'CART', CART=>$cart;
	$cart{'data.ship_firstname'} =  $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_SHIPPING,
			Google::Checkout::XML::Constants::BUYER_STRUCTURED_FIRSTNAME);
	$cart{'data.ship_lastname'} =  $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_SHIPPING,
			Google::Checkout::XML::Constants::BUYER_STRUCTURED_LASTNAME);
	$cart{'data.ship_company'} = 	$GN->get_buyer_info(Google::Checkout::XML::Constants::GET_SHIPPING,
                                        Google::Checkout::XML::Constants::BUYER_COMPANY_NAME);
	$cart{'data.ship_email'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_SHIPPING,
                                        Google::Checkout::XML::Constants::BUYER_EMAIL);
	$cart{'data.ship_phone'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_SHIPPING,
                                        Google::Checkout::XML::Constants::BUYER_PHONE);
	$cart{'data.ship_facsimile'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_SHIPPING,
                                        Google::Checkout::XML::Constants::BUYER_FAX);
	$cart{'data.ship_address1'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_SHIPPING,
                                        Google::Checkout::XML::Constants::BUYER_ADDRESS1);
	$cart{'data.ship_address2'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_SHIPPING,
                                        Google::Checkout::XML::Constants::BUYER_ADDRESS2);
	$cart{'data.ship_city'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_SHIPPING,
                                        Google::Checkout::XML::Constants::BUYER_CITY);
	$cart{'data.ship_state'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_SHIPPING,
                                        Google::Checkout::XML::Constants::BUYER_REGION);
	$cart{'data.ship_zip'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_SHIPPING,
                                        Google::Checkout::XML::Constants::BUYER_POSTAL_CODE);
	$cart{'data.ship_countrycode'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_SHIPPING,
                                        Google::Checkout::XML::Constants::BUYER_COUNTRY_CODE);

#	$cart{'data.bill_firstname'} = $bfirstname;
#	if ($bmi ne '') { $cart{'data.bill_middle'} = $bmi; }
#	$cart{'data.bill_lastname'} = $blastname;
	$cart{'data.bill_firstname'} =  $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_BILLING,
			Google::Checkout::XML::Constants::BUYER_STRUCTURED_FIRSTNAME);
	$cart{'data.bill_lastname'} =  $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_BILLING,
			Google::Checkout::XML::Constants::BUYER_STRUCTURED_LASTNAME);

	$cart{'data.bill_company'} = 	$GN->get_buyer_info(Google::Checkout::XML::Constants::GET_BILLING,
                                        Google::Checkout::XML::Constants::BUYER_COMPANY_NAME);
	$cart{'data.bill_email'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_BILLING,
                                        Google::Checkout::XML::Constants::BUYER_EMAIL);
	$cart{'data.bill_phone'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_BILLING,
                                        Google::Checkout::XML::Constants::BUYER_PHONE);
	$cart{'data.bill_facsimile'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_BILLING,
                                        Google::Checkout::XML::Constants::BUYER_FAX);
	$cart{'data.bill_address1'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_BILLING,
                                        Google::Checkout::XML::Constants::BUYER_ADDRESS1);
	$cart{'data.bill_address2'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_BILLING,
                                        Google::Checkout::XML::Constants::BUYER_ADDRESS2);
	$cart{'data.bill_city'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_BILLING,
                                        Google::Checkout::XML::Constants::BUYER_CITY);
	$cart{'data.bill_state'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_BILLING,
                                        Google::Checkout::XML::Constants::BUYER_REGION);
	$cart{'data.bill_zip'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_BILLING,
                                        Google::Checkout::XML::Constants::BUYER_POSTAL_CODE);
	$cart{'data.bill_countrycode'} = $GN->get_buyer_info(Google::Checkout::XML::Constants::GET_BILLING,
                                        Google::Checkout::XML::Constants::BUYER_COUNTRY_CODE);


	## copy the bill phone into the ship phone, if we didn't get a ship phone
	if (($cart{'data.bill_phone'} ne '') && ($cart{'data.ship_phone'} eq '')) {
		$cart{'data.ship_phone'} = $cart{'data.bill_phone'};
		}

	my $time_stamp    = $GN->get_timestamp;
	my $ful_state     = $GN->get_fulfillment_state;
	my $fin_state     = $GN->get_financial_state;
	my $email_allowed = $GN->marketing_email_allowed;
	my $calculation_s = $GN->merchant_calculation_successful;
	my $total_tax     = $GN->get_total_tax;
	my $adjust_total  = $GN->get_adjustment_total;
#	my $gc_cal_amount = $GN->get_gift_certificate_calculated_amount;
#	my $gc_app_amount = $GN->get_gift_certificate_applied_amount;
#	my $gc_cer_code   = $GN->get_gift_certificate_code;
#	my $gc_message    = $GN->get_gift_certificate_message;
#	my $cu_cal_amount = $GN->get_coupon_calculated_amount;
#	my $cu_app_amount = $GN->get_coupon_applied_amount;
#	my $cu_code       = $GN->get_coupon_code;
#	my $cu_message    = $GN->get_coupon_message;
	my $shipping_name = $GN->get_shipping_name || '';
	my $shipping_cost = $GN->get_shipping_cost;
	my $cart_expire   = $GN->get_cart_expiration;
	my $merchant_data = $GN->get_merchant_private_data;
	my $shipping_meth = $GN->get_shipping_method;

	$cart{'chkout.create_customer'} = 0;	
	if ($GN->marketing_email_allowed) {
		$cart{'chkout.create_customer'} = 1;
		}

	$cart{'chkout.payby'} = 'GOOGLE';
	$cart{'chkout.google_serial'} = $GN->get_serial_number;
	$cart{'chkout.google_orderid'} = $GN->get_order_number;
	$cart->shipping(0,1);

	my $shipmethod = $GN->get_shipping_name || 'Shipping Err';
	$cart{'ship.selected_method'} = $shipmethod;
	$cart{'ship.selected_price'} = $GN->get_shipping_cost;

	## NOTE: this line must be duplicated in merchant callback notifications
	my $handling = 0;
	foreach my $fee ('ship.hnd_total','ship.spc_total','ship.ins_total') {
		$handling += sprintf("%.2f",$cart->fetch_property($fee));
		}
	$cart{'ship.selected_price'} -= $handling;

	##  Hmmm.. eventually we should figure out what selected carrier is
	$cart{'ship.selected_carrier'} = '';
	if (defined $cart{'ship.%carriers'}) {
		if (defined $cart->{'ship.%carriers'}->{$shipmethod}) {
			$cart{'ship.selected_carrier'} = $cart->{'ship.%carriers'}->{$shipmethod};
			}
		}

	$cart{'ship.%methods'} = { $shipmethod=>$GN->get_shipping_cost };
	$cart{'ship.@methods_sorted'} = [ $shipmethod ];
	$cart{'payment_status'} = 111;
	## ship.selected_named = merchant-calculated-shipping-adjustment

	# print STDERR Dumper(\%cart);
	untie %cart;


	require ZWEBSITE;
	require CHECKOUT;
	my $webdbref = &ZWEBSITE::fetch_website_dbref($USERNAME,$PRT);
	my ($orderid, $success, $o) = &CHECKOUT::finalize($cart, $webdbref);

	$o->event(sprintf("Merchant Calculation Response[%s]",$GN->merchant_calculation_successful));
	$o->save();	## NOTE: 

	# print STDERR "ORDERID: $orderid\n";


	my $gco = &ZPAY::GOOGLE::buildGCO($USERNAME,$webdbref);
	$gco->send_notification_response();

	if ($orderid ne '') {
		## Inform Google of the order #
		require Google::Checkout::Command::AddMerchantOrderNumber;		
		my $add_merchant_order = Google::Checkout::Command::AddMerchantOrderNumber->new(
                         order_number          => $GN->get_order_number,
                         merchant_order_number => $orderid);
		my $run_diagnose = 0;
		my $response = $gco->command($add_merchant_order, $run_diagnose);
		
		if (not is_gco_error($response)) {
			$o->event("GC zoovy notified Google of Order #".$orderid,time(),1+2+4,'*google');
			}
		else {
			$o->event(sprintf("GC Google reported error during AddMerchantOrderNumber: %s",$response),time(),1+2+4+8,'*google');
			}
		$o->save();
		}

	## 
	## did we create an order? 
	##
	if ($orderid ne '') {
		## clear out the cart.
		$cart->empty();
		my ($MID) = &ZOOVY::resolve_mid($USERNAME);

		&DBINFO::insert($dbh,"GOOGLE_ORDERS",{
			'*CREATED'=>'now()',
			'USERNAME'=>$USERNAME,
			'MID'=>$MID,
			'GOOGLE_ORDERID'=>$GN->get_order_number(),
			'ZOOVY_ORDERID'=>$orderid,
			},debug=>1);
		}


	$GN = undef;

	}




##
##
##
if ( (defined $GN) && ($GN->type eq 'merchant-calculation-callback') ) {


	my $cart = &ZPAY::GOOGLE::decodeCart($GN->get_merchant_private_data);
	my $USERNAME = $cart->{'username'};
	my $CARTID = $cart->{'id'};

	my $webdbref = &ZWEBSITE::fetch_website_dbref($USERNAME,$PRT);
	if ($webdbref->{'google_api_merchantcalc'}==0) {
		warn "merchant calculations disabled!";
		die();
		}

	##
	## 
	my @SHIPMETHODS = ();	


	#--
	#-- Show anonymous addresses
	#--
	my $addresses = $GN->get_addresses;

	for my $address (@$addresses) {
		$cart->save_property('cgi.address','');
		$cart->save_property('cgi.zip', $address->{'postal_code'});
		$cart->save_property('cgi.state', $address->{'region'});
		$cart->save_property('cgi.countrycode', $address->{'country_code'});
		$cart->shipping(0,1);  
  
#		open F, ">>/tmp/cart";
#		print Dumper($cart);
#		close F;

		my $methodsref = $cart->fetch_property('ship.%methods');
		foreach my $method (keys %{$methodsref}) {
			# print "METHOD: $method\n";
			$address->{'shipping-rate'} = $methodsref->{$method};
			$address->{'shipping-name'} = $method;
			$address->{'total-tax'} = $cart->fetch_property('data.tax_total');
			
			# $address->{'total-tax'} = 100;
			$address->{'shippable'} = 1;
			if ($address->{'shipping-name'} =~ /Actual Cost/i) { $address->{'shippable'} = 0; }

			## NOTE: this code must be duplicated in new-order-notification
			my $handling = 0;
			foreach my $fee ('ship.hnd_total','ship.spc_total','ship.ins_total') {
				$handling += sprintf("%.2f",$cart->fetch_property($fee));
				}

			my $gmethod = Google::Checkout::General::MerchantCalculationResult->new(
             shipping_name                 => $address->{'shipping-name'},
             address_id                    => $address->{'id'},

	## DO NOT COMMENT THIS LINE UNDER PENALTY OF DEATH - MERCHANT CALCULATIONS TAX IS BROKED.
             total_tax                     => $address->{'total-tax'},

             shipping_rate                 => sprintf("%.2f",$address->{'shipping-rate'}+$handling),
             shippable                     => $address->{'shippable'},
   #          valid_coupon                  => 0,
   #          valid_certificate             => 0,
   #          coupon_calculated_amount      => 13.45,
   #          certificate_calculated_amount => 45.56,
   #          coupon_code                   => $coupons[0],
   #          certificate_code              => $certificates[0],
   #          coupon_message                => "coupon is valid",
   #          certificate_message           => "certificate is valid"
				);
	
			push @SHIPMETHODS, $gmethod;


			}

		# $address->{'addrid'} = $addrid;
		#$address->{'shipping-rate'} = $cart->fetch_property('ship.selected_price');
		#$address->{'shipping-name'} = $cart->fetch_property('ship.selected_method');

		#--
		#-- Create a merchant calculation result object.
		#-- All the coupon and certificate stuff are optional
		#--
		}

	
#	open F, ">>/tmp/asdf";
#	use Data::Dumper; print F Dumper(\@SHIPMETHODS);
#	close F;


	#--
	#-- Get a list of coupons and gift certificates. It's up to
	#-- the business partner to determin whether the code is a
	#-- coupon or a gift certificate. We get back an array reference
	#--
	#my $coupons_certificates = $GN->get_merchant_code_strings;
	#
	#my (@coupons, @certificates);
	#
	#for (@$coupons_certificates)
	#{
	#  #--
	#  #-- If the code has the string 'coupon' in it, assume it's a coupon code.
	#  #-- Partner might use a completely different rule to determine this
	#  #--
	#  if (/coupon/i)
	#  {
	#    push @coupons, $_;
	#  }
	#  else
	#  {
	#    push @certificates, $_;
	#  }
	#}

	#--
	#-- This sends the merchant calculation back to GCO.
	#-- Partner will likely run this in some sort of CGI
	#-- enviroment since it outputs a text/xml header as well
	#--
	my $gco = &ZPAY::GOOGLE::buildGCO($USERNAME,$webdbref);
	$gco->send_merchant_calculation(\@SHIPMETHODS);

	$GN = undef;
	}



if (defined $GN) {
	## some type of error occurred
	require SUPPORT;
	use Data::Dumper;
	SUPPORT::createticket($USERNAME,LUSER=>"googlecheckout",BODY=>qq~
This support ticket was automatically created because Zoovy received a notification for a
Google Order that we do not have a record of. Details of the notification can be found below:

~.Dumper($GN),SUBJECT=>"Google Checkout Error");

	my $webdbref = &ZWEBSITE::fetch_website_dbref($USERNAME,$PRT);
	my $gco = &ZPAY::GOOGLE::buildGCO($USERNAME,$webdbref);
	if (not defined $gco) {
		}
	$gco->send_notification_response();
	
	}
elsif (not defined $GN) {
	my $pstmt = "update GOOGLE_NOTIFICATIONS set PROCESSED_GMT=".time()." where ID=".int($dbID);
	# print STDERR "\n".$pstmt."\n";
	$dbh->do($pstmt);
	}

&DBINFO::db_zoovy_close();


#open F, ">/tmp/callback";
#print F Dumper($USERNAME,$CARTID,$xml,\%ENV);
#close F;
