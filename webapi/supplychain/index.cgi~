#!/usr/bin/perl

use strict;
use Text::CSV_XS;
use Tie::Hash::Indexed;
use lib '/httpd/modules';
require ZTOOLKIT;
require CUSTOMER;
require DOMAIN::TOOLS;
require DOMAIN::RESOLVE;
require IMGLIB::Lite;
require WHOLESALE;
require ZOOVY;

if ($ENV{'REQUEST_URI'} =~ /^.*\/webapi\/supplychain\/index\.cgi\/([A-Z0-9]+)\/(.*?\.xml)$/) {
	## OLD DEPRECATED SUPPLY CHAIN CRAP -- IGNORE THIS!
	## REQUEST_URI = http://webapi.zoovy.com/webapi/supplychain/index.cgi/ZSMC/testlist1.xml
	## http://webapi.zoovy.com/webapi/supplychain/index.cgi/SUPPLYCHAIN/heidi.xml
	##	http://webapi.zoovy.com/webapi/supplychain/index.cgi/GREATLOOKZ/royal_trend_misc.xml
	##
	my $buf = '';
	my $MERCHANT = $1;
	my $FILE = $2;
	my 	$path = &ZOOVY::resolve_userpath($MERCHANT).'/IMAGES/'.$FILE;
	open F, "<$path"; $/ = undef; $buf = <F>; close F; $/ = "\n";

	if ($buf eq '') {
		print "Content-type: text/error\n\n";
		print "File could not be found!\n";
		}
	else {
		print "Content-type: text/xml\n\n$buf";
		}
	exit;
	}

use CGI;
my ($q) = CGI->new();

my $verb = $q->param('verb');
my $domain = $q->param('store');
my $login = $q->param('login');
my $pass = $q->param('pass');
my $format = uc($q->param('format'));

# $domain = 'gkworld.com'; $login = 'jmiewald@yahoo.com'; $pass = 'anime'; $verb = 'checkAccess';
#$verb = 'checkAccess'; $format = 'ini'; 
# $verb = 'getProducts'; $format = 'uri';

$format = uc($format);

##
## ?login=user@doamin.com&pass=secret&store=domain.com&verb=checkAccess&getProducts|getInventory&format=csv|xml|ini
##

if ($verb eq '') {
	print "Content-type: text/html\n\n";
	print qq~
<html>
<pre>
Supplier WebAPI
----------------

This is a REST based API which allows you to access Products, and Inventory the URL format is:
http://webapi.zoovy.com/supplychain/index.cgi?login=[yourlogin]&pass=[yourpass]&store=[domain.com]&verb=[verb]&format=[format]

valid verbs:
------------
checkAccess
	format=ini
	** this will return text/plain content type with an ini-formatted success or error message

getProducts
	format=xml|csv|uri
	** this will return either a text/xml or text/csv (determined by format) with a dump
	** of product data.

getInventory
	format=xml|csv
	** this will return either a text/xml or text/csv (determeind by format) with a dump
	** of inventory data.


</pre>
</html>
	~;
	exit;
	}

##
## checkAccess format=ini
##	
##	success=0|1
## error=meaningful error or blank
##	productcount=####
##
my $error = undef;
if ((not $error) && ($verb eq '')) {
	$error = 'parameter "verb" not defined.';
	}

if ((not $error) && ($login eq '')) {
	$error = 'parameter "login" not defined.';
	}

if ((not $error) && ($pass eq '')) {
	$error = 'parameter "pass" not defined.';
	}

if ((not $error) && ($domain eq '')) {
	$error = 'parameter "store" not defined.';
	}

my ($USERNAME,$dataref) = ();
if (not $error) {	
	($USERNAME) = &DOMAIN::RESOLVE::resolve_domain_to_user($domain);
	if (not defined $USERNAME) { $error = "domain \"$domain\" was not found."; }
	}

if (not $error) {
	($dataref) = &DOMAIN::TOOLS::getinfo($USERNAME,$domain);
	if (not defined $dataref) { $error = "data for domain \"$domain\" was not found."; }
	}

my ($MID,$CLUSTER,$PRT) = ();
if (not $error) {
	($PRT) = $dataref->{'prt'};
	($MID) = &ZOOVY::resolve_mid($USERNAME);
	($CLUSTER) = &ZOOVY::resolve_cluster($USERNAME);
	if ((not $error) && ($MID<=0)) {
		$error = "merchant \"$USERNAME\" is not valid.";
		}
	}



my ($CID) = (0);
if (not $error) {
	# print "($USERNAME,$login,$PRT)\n";
	my ($exists) = &CUSTOMER::customer_exists($USERNAME,$login,$PRT);
	if (not $exists) { 
		$error = "Could not lookup customer record for \"$login\"";
		}
	}

if (not $error) {
	($CID) = &CUSTOMER::authenticate($USERNAME,$PRT, $login, $pass);
	if ($CID<1) {
		$error = "Invalid password for user \"$login\"";
		}	
	}

my ($SCHEDULE) = ();
if (not $error) {
	my ($C) = CUSTOMER->new($USERNAME,CID=>$CID,INIT=>0xFF);
	$SCHEDULE = $dataref->{'schedule'};
	if ((not defined $C) || (ref($C) ne 'CUSTOMER')) {
		$error = "Could not load customer record for customer #$CID";
		}
	elsif ($C->fetch_attrib('INFO.SCHEDULE') eq '') {
		$error = "Customer #$CID is not a wholesale client";
		}
	else {
		$SCHEDULE = $C->fetch_attrib('INFO.SCHEDULE');
		}
	}


my ($csv) = ();
if (not $error) {
	if ($format eq 'CSV') { $format = 1; }
	elsif ($format eq 'XML') { $format = 2; }
	elsif ($format eq 'URI') { $format = 3; }
	elsif ($verb eq 'checkAccess') { $format = 0; }
	else { $error = "Invalid format \"$format\""; }

	if ($error) { $verb = 'checkAccess'; $format = 0; }

	if ($format==0) {
		print "Content-type: text/ini\n\n";
		}
	elsif ($format==1) {
		print "Content-type: text/csv\n\n";
		$csv = Text::CSV_XS->new({ binary => 1 });
		}
	elsif ($format==2) {
		print "Content-type: text/xml\n\n";
		print "<?xml version=\"1.0\"?>\n";
		}
	elsif ($format==3) {
		print "Content-type: text/plain\n\n";
		}
	}



if ($verb eq 'checkAccess') {
	print "merchant=$USERNAME\n";
	print "login=$login\n";
	my ($success) = ($error eq '')?1:0;
	print "success=$success\n";
	if (not $success) {
		print "error=$error\n";
		}
	else {
		print "rootcat=$dataref->{'rootcat'}\n";
		print "schedule=$SCHEDULE\n";
		print "cid=$CID\n";
		my ($NC) = NAVCAT->new($USERNAME);
		my $ref = $NC->okay_to_show($USERNAME,undef,$dataref->{'rootcat'});
		#my ($ref) = ZOOVY::fetchproducts_by_nameref($USERNAME);
	
		my @pids = keys %{$ref};
		print "product_count=".scalar(@pids)."\n";
		print "\n";
		}
	}
elsif ($verb eq 'getProducts') {
	##
	##
	tie my %columns, 'Tie::Hash::Indexed';
	if ($format==1) { print("PID,TITLE,PRICE,MSRP,IMAGEURL,DESCRIPTION\n"); }
	if ($format==2) { print("<products>"); }

	## changed to use okay_to_show - patti - 2008-05-21
	## takes into account the profile for the site, hidden categories
	## 	if products are in-stock		
	require NAVCAT;
	my ($NC) = NAVCAT->new($USERNAME);
	my $ref = $NC->okay_to_show($USERNAME,undef,$dataref->{'rootcat'});
	#my ($ref) = ZOOVY::fetchproducts_by_nameref($USERNAME);

	my @pids = keys %{$ref};
	@pids = splice @pids, 1, 10; 
	my $prodsref = ZOOVY::fetchproducts_into_hashref($USERNAME,\@pids);
	
	
	foreach my $pid (@pids) {
		## added tweak_product - patti - 2008-05-21
		require WHOLESALE;
		WHOLESALE::tweak_product($USERNAME,$SCHEDULE,$prodsref->{$pid});
		
		my $image = &IMGLIB::Lite::url_to_image($USERNAME,$prodsref->{$pid}->{'zoovy:prod_image1'},0,0,'',0);
		if ($format == 1) {
			## csv
			my @COLUMNS = ();
			push @COLUMNS, $pid;
			push @COLUMNS, $prodsref->{$pid}->{'zoovy:prod_name'};
			push @COLUMNS, $prodsref->{$pid}->{'zoovy:base_price'};
			push @COLUMNS, $prodsref->{$pid}->{'zoovy:prod_msrp'};
			push @COLUMNS, $image;
			push @COLUMNS, $prodsref->{$pid}->{'zoovy:prod_desc'};
			my $status = $csv->combine(@COLUMNS);	# combine columns into a string
			print($csv->string()."\r\n"); 			# get the combined string
			}
		elsif ($format == 2) {
			my %columns = ( 
				'pid'=>$pid, 
				'title'=>$prodsref->{$pid}->{'zoovy:prod_name'},
				'price'=>$prodsref->{$pid}->{'zoovy:base_price'},
				'msrp'=>$prodsref->{$pid}->{'zoovy:prod_msrp'},
				'imageurl'=>$image,
				'description'=>$prodsref->{$pid}->{'zoovy:prod_desc'}
				);
			print(&ZTOOLKIT::arrayref_to_xmlish_list([\%columns],
					tag=>'product'));
			}
		elsif ($format == 3) {
			## JEDI/URI format

			##	step1: convert images to urls
			my $attrib = '';
			for(my $i=0;$i<99;$i++) {
				if ($i==0) { $attrib = "zoovy:prod_thumb"; }
				else { $attrib = "zoovy:prod_image$1"; }
				next if ($prodsref->{$pid}->{$attrib} eq '');
				$prodsref->{$pid}->{$attrib} = &IMGLIB::Lite::url_to_image($USERNAME,$prodsref->{$pid}->{$attrib},0,0,'',0);
				}
			## step2: strip fields.
			delete $prodsref->{$pid}->{"zoovy:base_cost"};
			print $pid.'?'.&ZTOOLKIT::buildparams($prodsref->{$pid})."\r\n";
			}
		}

	if ($format==2) { print("</products>"); }
	}
elsif ($verb eq 'getInventory') {
	tie my %columns, 'Tie::Hash::Indexed';
	if ($format==1) { print("SKU,QTY,ONORDER\n"); }
	if ($format==2) { print("<inventory>"); }

	my ($invref, $reserveref, $onorder) = &INVENTORY::load_records($USERNAME,undef,8+16+128);	
	#use Data::Dumper;
	#print Dumper($invref);

	foreach my $sku (keys %{$invref}) {
		%columns = ( 'sku'=>$sku, 'available'=>$invref->{$sku}, 'onorder'=>$onorder->{$sku} );
		if ($format==1) {
			my $status = $csv->combine(values %columns);    # combine columns into a string
			print($csv->string()."\r\n");               # get the combined string
			}
		else {
			print(&ZTOOLKIT::arrayref_to_xmlish_list([\%columns],tag=>'inv'));
			}
		}

	if ($format==2) { print("</inventory>"); }
	}






 