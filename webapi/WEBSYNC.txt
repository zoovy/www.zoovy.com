package WEBSYNC;

use LWP::UserAgent;
use XML::Parser;
use XML::Parser::EasyTree;
use Storable;
use Data::Dumper;
use strict;

##
## Purpose: Makes webapi request.
## Returns: xml output from Zoovy
## Pass: 
##
sub doRequest {
   my ($USERNAME,$PASSWORD,$API,$REQUESTID,$DATA,$SECURE,$ERRORREF) = @_;

	print STDERR "\n\n\n\nStarting $API request [$REQUESTID]\n";
   my $header = HTTP::Headers->new;

	my $COMPRESS = 'NONE';
#	$COMPRESS = 'GZIP';

	if ($COMPRESS eq 'BZIP2') {
		require Compress::Bzip2;
		$DATA = Compress::Bzip2::compress($DATA,9);
		}
	elsif ($COMPRESS eq 'GZIP') {
		require Compress::Zlib;
		$DATA = Compress::Zlib::memGzip($DATA);
		}

	$USERNAME = uc($USERNAME);
	my $t = time();

   $header->push_header('X-ZOOVY-USERNAME' => $USERNAME);
   $header->push_header('X-ZOOVY-API' => $API);
	$header->push_header('X-LENGTH' => length($DATA));
	$header->push_header('X-COMPRESS' => $COMPRESS);
	$header->push_header('X-TIME' => $t );
	$header->push_header('X-ZOOVY-REQUEST' => $REQUESTID);

	use Digest::MD5;
	my $SECURITY = Digest::MD5::md5_hex( $USERNAME . $PASSWORD . $API . $REQUESTID . $t . $DATA );
	$header->push_header('X-ZOOVY-SECURITY' => $SECURITY);
   $header->push_header('Content-Type' => 'application/'.$API);

	my $URL = 'http://www.zoovy.com/webapi/sync.cgi';
	if ($SECURE) { $URL = 'https://www.zoovy.com/webapi/sync.cgi'; }

	my $request = $DATA;
	my $agent = LWP::UserAgent->new();
	my $result =  $agent->request(HTTP::Request->new("POST", $URL, $header, $request));

	if ($result->content_type() eq 'text/xml') {
	   return($result->content());
		}
	else {
		$ERRORREF->{$REQUESTID} = "-1: Received Unknown Response Type: ".$result->content_type()."\n\n".$result->content();
		return(undef);
		}
	}



sub parseRequest {
	my ($USERNAME,$PASSWORD,$DATA,$IMPATIENT,$WAITREF,$RESULTREF,$ERRORREF) = @_;

	if (not defined $DATA) { 
		return(undef); 
		}

	my $p = new XML::Parser(Style=>'EasyTree');
	$XML::Parser::EasyTree::Noempty=1;
	if (not defined $p) { return(undef); }

	if (not defined $WAITREF) {
		my @WAITAR = (); $WAITREF = \@WAITAR;
		}
	if (not defined $RESULTREF) {
		my %RESULTREF = (); $RESULTREF = \%RESULTREF;
		}

	my $st = -1;
	my $tree = $p->parse($DATA);
	$tree = $tree->[0]->{'content'};
	foreach my $node (@{$tree}) {
		next if ($node->{'type'} ne 'e');
		next if ($node->{'name'} eq 'SysInfo');
		next if ($node->{'name'} eq 'Api');
		next if ($node->{'name'} eq 'Debug');
		
		if ($node->{'name'} eq 'Errors') {
			foreach my $err (@{$node->{'content'}}) {
				next if ($err->{'type'} ne 'e');
				next if ($err->{'name'} ne 'Error');
				$ERRORREF->{$err->{'attrib'}->{'Id'}} = $err->{'attrib'}->{'Code'}.': '.$err->{'content'}->[0]->{'content'};
				}
			}
		
		if ($node->{'name'} eq 'Time') {
			$st = $node->{'content'}->[0]->{'content'};
			if ((time() >= ($st+30)) || (time() <= ($st-30))) {
				print STDERR "Warning: Server Time is: ".$st." local time is ".time()." variance: ".($st-time())."\n";
				}
			}

		if ($node->{'name'} eq 'Request') {
			if ($node->{'attrib'}->{'PickupTime'}==0) {
				$RESULTREF->{ $node->{'attrib'}->{'Id'} } = $node->{'content'}->[0]->{'content'};
				}
			else {
				##
				## WAIT nodes have the following values:
				##		PickupTime
				##		Id
				##
				push @{$WAITREF}, Storable::dclone($node->{'attrib'});
				}
			}
		}
	$tree = undef;
	$p = undef;

	## SANITY: at this point $WAITREF is an array ref of things we're waiting for.
	if ($IMPATIENT) {
		## Impatient requests never wait (even if they've been told to), they just append to WAITREF
		## this lets the application keep sending new requests, and just adding stuff to the wait stack.
		## e.g. turbo pipeline mode.
		}
	elsif (scalar(@{$WAITREF})>0) {
		print "WAIT QUEUE:\n".Dumper($WAITREF);
		## this is a patient connection, it will hang out till all requests are answered.
		## .. go through the wait ref, figure out the shortest length we ought to hang out.
		while (scalar(@{$WAITREF}>0)) {

			## STEP1: find the shortest line (the lowest/soonest wait time value)
			my $low = time()+3600;
			foreach my $w (@{$WAITREF}) {
				if ($w->{'PickupTime'} < $low) { $low = $w->{'PickupTime'}; }
				}
			
			## STEP2: take a nap (yawn!) 
			print "SLEEPING FOR: ".($low - time())." seconds\n";
			sleep($low - time());

			## STEP3: Has the line moved? 
			my $counter=0;
			foreach my $w (@{$WAITREF}) {
				$counter++;								
				next if ($w->{'PickupTime'}>time());
				delete @{$WAITREF}[$counter-1];		## delete this out of the array
				print "ATTEMPTING TO DOWNLOAD:\n".Dumper($w);

				my $DATA = &doRequest($USERNAME,$PASSWORD,'PICKUP/'.$w->{'Id'},$w->{'Id'},'');
				&parseRequest($USERNAME,$PASSWORD,$DATA,1,$WAITREF,$RESULTREF,$ERRORREF);
				}

			}
		}
	
	return($RESULTREF);
	}


sub demo {
	my $ID = 'demo-'.time();
	my ($USERNAME,$PASSWORD,$DATA) = @_;

	my $resultref = undef;
	#($out) = doRequest($USERNAME,$PASSWORD,'TEST/ECHO',$ID,$DATA);
	#($out) = doRequest($USERNAME,$PASSWORD,'TEST/REVERSE',$ID,$DATA);

	my %ERRORS = ();
	my %RESULTS = ();

	## this is an example of patient connection (meaning it will block until the data is received)
	if (0) {
		my $resultref = {};
		my ($out) = doRequest($USERNAME,$PASSWORD,'TEST/ECHODELAY',$ID,$DATA,\%ERRORS);
		print STDERR Dumper($out);
		if (not defined $out) { $RESULTS{$ID} = undef; }
		else {
			$resultref = &parseRequest($USERNAME,$PASSWORD,$out,0,undef,undef,\%ERRORS);
			}
		}

	## this is an example of an impatient connection (meaning it will just send the request)
	print Dumper($resultref,\%ERRORS);
	# print "out: $out\n";
	}

1;
