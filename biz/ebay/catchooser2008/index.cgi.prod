#!/usr/bin/perl -w
##
## CGI-style script with dispatcher here. Allows browsing between categories, viewing item specifics
## one-attribute search, working with product finders and viewing prefilled specifics set.
##
## IMPORTANT! config is in modules/ebayConfig.pm
##
use strict;
use DBI;
use Template;
use CGI::Carp qw(fatalsToBrowser);
use CGI qw(Vars param);
use XML::Parser;
use XML::SimpleObject;
use URI::Escape;
use File::Temp;
#use FindBin;
#use lib "$FindBin::Bin/lib";
use lib '/httpd/modules';
use ebayConfig;
use ebayUtils;
use ebayAPI;
require ZOOVY;
require LUSER;
#chdir "..";

my ($edbh, $cgi, $action, $param, $dispatch, $stash, $rendered,
    $PRODUCT_ID, $MID, $USERNAME, $LUSERNAME, $FLAGS, $PRT, $V);
my $XALAN = '/usr/local/xalan/bin/Xalan';

init();
dispatch();
end();

sub init {
  $edbh = DBI->connect($CONNECT_INFO->[0], $CONNECT_INFO->[1], $CONNECT_INFO->[2], $CONNECT_INFO->[3]);
  $cgi = new CGI;
  ($MID, $USERNAME, $LUSERNAME, $FLAGS, $PRT) = LUSER->authenticate(sendto=>"/biz",scalar=>1,nocache=>1,session_id=>$ZOOVY::cgiv->{'session_id'});
  ##$stash->{MID} = $MID; $stash->{USERNAME} = $USERNAME; $stash->{LUSERNAME} = $LUSERNAME; $stash->{FLAGS} = $FLAGS;  $stash->{PRT} = $PRT;

  my @uri = split '/', $ENV{'REQUEST_URI'}; ## contains /biz/ebay/catchooser2008/index.cgi/action
  ($action = $uri[5] || 'index') =~ s/\?.*//;

  $param = Vars();
  delete $param->{id} if $param->{id} and $param->{id} =~ /\D/; ## only digits allowed
  $PRODUCT_ID = $param->{PID};
  $PRODUCT_ID ||= $cgi->cookie('PID');
  $V = $param->{V};
  $V ||= $cgi->cookie('V');

  my $categories;
  my $sth = $edbh->prepare("SELECT ebay_categories.id, ebay_categories.name FROM ebay_categories, ebay_last_categories WHERE ebay_last_categories.user_id = $MID AND ebay_categories.id = ebay_last_categories.category_id ORDER BY ebay_last_categories.create_timestamp DESC") or die $edbh->errstr;
  $sth->execute or die $sth->errstr;
  while ( my ($cat_id, $cat_name) = $sth->fetchrow_array ) {
    my $cat = {};
    $cat->{id} = $cat_id;
    $cat->{name} = $cat_name;
    push @$categories, $cat;
  }
  $stash->{last_categories} = $categories;
}

sub end {
  $edbh->disconnect or warn $edbh->errstr;
}

sub render {
  my ($file) = @_;
  my $template;
  $stash->{action} = $action;

  $stash->{nowrapper} = 1 if ($ENV{HTTP_X_REQUESTED_WITH} and $ENV{HTTP_X_REQUESTED_WITH} eq 'XMLHttpRequest');
  $template = Template->new({
    INCLUDE_PATH => $TEMPLATES_PATH,
    WRAPPER => 'wrapper.tt2'
  });

  my $pid_cookie = $cgi->cookie(
    -name=>'PID',
		-value=>$PRODUCT_ID,
		-expires=>'+1h',
		-path=>'/biz/ebay/catchooser2008'
  );
  my $v_cookie = $cgi->cookie(
    -name=>'V',
		-value=>$V,
		-expires=>'+1h',
		-path=>'/biz/ebay/catchooser2008'
  );

  if(!$rendered) {
    if($stash->{xml}) {
      #print "Content-Type: text/xml; charset=utf8\n\n";
      print $cgi->header(
        -type=>'text/xml',
        -charset=>'utf-8'
      );
    } else {
      #print "Content-Type: text/html; charset=uft8\n\n";
      print $cgi->header(
        -type=>'text/html',
        -charset=>'utf-8',
        -cookie=>[$pid_cookie,$v_cookie]
      );
    }
    $template->process($file, $stash); $rendered = 1;
  }
}

## ACTIONS GO HERE
##
sub index {
  render('index.tt2');
}

sub get_categories {
  prepare_category_tree();
  my $selected_category = $stash->{selected_category};

  if($selected_category && $selected_category->{leaf}) {
    ## leaf category is a place where you can add your item.
    ## so we gonna to render One-Attribute Search form (for categories with
    ## ProductSearchPageAvailable) or Product Finder form (for categories,
    ## supportion product finders) or simply render 'Describe your item'
    ## with choose custom specifics form if any.

    ##update last 10 categories
    my $sth = $edbh->prepare("SELECT count(category_id) FROM ebay_last_categories WHERE user_id = ?") or die $edbh->errstr;
    $sth->execute($MID) or die $sth->errstr;
    my $count = $sth->fetchrow_array;

    if ($count < 10) { ## less than 10 categories in list - create new or update timestamp if exists
      $sth = $edbh->prepare("SELECT category_id FROM ebay_last_categories WHERE user_id = ? AND category_id = ?") or die $edbh->errstr;
      $sth->execute($MID, $selected_category->{id}) or die $sth->errstr;
      my $category_id = $sth->fetchrow_array;
      if($category_id) {
        $sth = $edbh->prepare("UPDATE ebay_last_categories SET create_timestamp = ? WHERE user_id = ? AND category_id = ?") or die $edbh->errstr;
        $sth->execute(timestamp, $MID, $selected_category->{id}) or die $sth->errstr;
      } else {
        $sth = $edbh->prepare("INSERT INTO ebay_last_categories(user_id, category_id, create_timestamp) VALUES(?,?,?)") or die $edbh->errstr;
        $sth->execute($MID, $selected_category->{id}, timestamp) or die $sth->errstr;
      }
    } else { ## 10 categories in list - update oldest one - set new category_id and timestamp
      $sth = $edbh->prepare("SELECT category_id FROM ebay_last_categories WHERE user_id = ? AND category_id = ?") or die $edbh->errstr;
      $sth->execute($MID, $selected_category->{id}) or die $sth->errstr;
      my $category_id = $sth->fetchrow_array;
      if($category_id) {
        $sth = $edbh->prepare("UPDATE ebay_last_categories SET create_timestamp = ? WHERE user_id = ? AND category_id = ?") or die $edbh->errstr;
        $sth->execute(timestamp, $MID, $selected_category->{id}) or die $sth->errstr;
      } else {
        $sth = $edbh->prepare("SELECT category_id FROM ebay_last_categories WHERE user_id = ? ORDER BY create_timestamp ASC LIMIT 1") or die $edbh->errstr;
        $sth->execute($MID) or die $sth->errstr;
        my $oldest = $sth->fetchrow_array();
        $sth = $edbh->prepare("UPDATE ebay_last_categories SET category_id = ?, create_timestamp = ? WHERE user_id = ? AND category_id = ?") or die $edbh->errstr;
        $sth->execute($selected_category->{id}, timestamp, $MID, $oldest) or die $sth->errstr;
      }
    }

    ## If user selects Secondary eBay category - just render 'Save' button, not allowing choose custom specifics
#    if($V eq 'ebay:category2') {
#      $stash->{secondary} = 1;
#      render('get_categories.tt2');
#      return;
#    }

    my $sth = $edbh->prepare('SELECT ebay_product_finders.data_present FROM ebay_category_2_product_finder, ebay_product_finders WHERE ebay_product_finders.id = ebay_category_2_product_finder.product_finder_id AND ebay_category_2_product_finder.category_id = '.$selected_category->{id}) or die $edbh->errstr;
    $sth->execute or die $sth->errstr;
    my $pf_available = $sth->fetchrow_array;
    ## if Both ProductSearchPage and ProductFinder available
    ## prepare them and render both.
    if($selected_category->{product_search_page_available} && $pf_available) {
      show_sp_pf_form();
    }

    ## if only ProductSearchPageAvailable
    ## prepare one-attribute search form and show it to user
    elsif($selected_category->{product_search_page_available}) {
      show_sp_form();
    }

    ## if only ProductFinder available
    ## prepare PF form and render it to user
    ## product_finder->data_present check below is a tricky eBay move
    ## some categories has product finder support declared, but when you make a call
    ## to get ProductFinder Data - it returns XML with Success
    ## but without ProductFinderData section!!!
    elsif( $pf_available ) {
      show_pf_form();
    }

    ## if none of above available
    ## just render describe item form (not prefilled)
    else { describe_item(); }

  } else {
    ## just render category tree
    render('get_categories.tt2');
  }
}

##
## takes query and tries to suggest category to list (with % item match)
sub get_suggested_categories {
  if($param->{'query'}) {
    $stash->{'query'} = $param->{'query'};
    my $api = new ebayAPI;
    my $xml = $api->getSuggestedCategories(str_safe($param->{query}));
    if($xml && $xml !~ /An Error Occurred/) {
      my $parser = new XML::Parser (ErrorContext => 2, Style => "Tree");
      my $xmlobj = new XML::SimpleObject ($parser->parse($xml));
      if( $xmlobj->child('GetSuggestedCategoriesResponse')->child('Ack')->value eq 'Warning' ||
          $xmlobj->child('GetSuggestedCategoriesResponse')->child('Ack')->value eq 'Failure') {
        $stash->{'error'} = 'eBay returned after GetSuggestedCategories: '.$xmlobj->child('GetSuggestedCategoriesResponse')->child('Errors')->child('LongMessage')->value;
        $stash->{'error'} =~ s/ <0>//;
      } elsif($xmlobj->child('GetSuggestedCategoriesResponse')->child('Ack')->value eq 'Success') {
        $stash->{'category_count'} = $xmlobj->child('GetSuggestedCategoriesResponse')->child('CategoryCount')->value;
        if($xmlobj->child('GetSuggestedCategoriesResponse')->child('SuggestedCategoryArray')) {
          foreach my $category ($xmlobj->child('GetSuggestedCategoriesResponse')->child('SuggestedCategoryArray')->child('SuggestedCategory')) {
            my $category_to_template = {};
            $category_to_template->{id} = $category->child('Category')->child('CategoryID')->value;
            $category_to_template->{name} = $category->child('Category')->child('CategoryName')->value;
            $category_to_template->{percentage} = $category->child('PercentItemFound')->value;
            push @{$stash->{'categories'}}, $category_to_template;
          }
        }
      }
    } else {
      $stash->{'error'} = "Category Suggest - Cannot make call to eBay";
    }
  }
  render('suggested_categories.tt2');
}

##
## just renders 'describe item form'
sub describe_item {
  prepare_category_tree() if not defined $stash->{'selected_category'};
  prepare_cs_form();
  render('add_item.tt2');
}

##
## renders both one attribute search form and product finder for selected category
sub show_sp_pf_form {
  prepare_category_tree() if not defined $stash->{'selected_category'};
  my $selected_category = $stash->{'selected_category'};
  if( $selected_category->{product_search_page_available} ) {
    prepare_sp_form();
  }

  my $sth = $edbh->prepare('SELECT ebay_product_finders.data_present FROM ebay_category_2_product_finder, ebay_product_finders WHERE ebay_product_finders.id = ebay_category_2_product_finder.product_finder_id AND ebay_category_2_product_finder.category_id = '.$selected_category->{id}) or die $edbh->errstr;
  $sth->execute or die $sth->errstr;
  my $pf_available = $sth->fetchrow_array;
  if( $pf_available ) {
    prepare_pf_form();
  }
  render('sp_and_pf_form.tt2');
}

##
## renders one attribute search form for selected category
sub show_sp_form {
  prepare_category_tree() if not defined $stash->{'selected_category'};
  my $selected_category = $stash->{'selected_category'};
  if( $selected_category->{product_search_page_available} ) {
    prepare_sp_form();
  }
  render('search_page_form.tt2');
}

##
## renders product finder form for selected category
sub show_pf_form {
  prepare_category_tree() if not defined $stash->{'selected_category'};
  my $selected_category = $stash->{'selected_category'};

  my $sth = $edbh->prepare('SELECT ebay_product_finders.data_present FROM ebay_category_2_product_finder, ebay_product_finders WHERE ebay_product_finders.id = ebay_category_2_product_finder.product_finder_id AND ebay_category_2_product_finder.category_id = '.$selected_category->{id}) or die $edbh->errstr;
  $sth->execute or die $sth->errstr;
  my $pf_available = $sth->fetchrow_array;

  if( $pf_available ) {
    prepare_pf_form();
  }
  render('product_finder_form.tt2');
}

##
## takes data from One-attribute search form or ProductFinder form
## calls GetProductSearchResult and renders found items to user
sub get_product_search_results {
  prepare_category_tree() if not defined $stash->{'selected_category'};
  my $selected_category = $stash->{'selected_category'};
  my $xml = '';

  if($param->{'sp_search'}) {
    ## One-attribute search
    my $attribute_set_id = $param->{'attribute_set_id'};
    $stash->{'attribute_set_id'} = $attribute_set_id;
    my $attribute_id = $param->{'attribute_id'};
    my $attribute_value = str_safe($param->{'attribute_value'});
    my $in_xml = "<ProductSearch>
    <AttributeSetID>$attribute_set_id</AttributeSetID>
      <SearchAttributes>
        <AttributeID>$attribute_id</AttributeID>
        <ValueList>
          <ValueLiteral>$attribute_value</ValueLiteral>
        </ValueList>
      </SearchAttributes>
    </ProductSearch>";
    my $api = new ebayAPI;
    #open F, "$PATH_TO_STATIC/xml/GetProductSearchResults/sample.xml"; $xml .= $_ while(<F>); close F;
    $xml = $api->getProductSearchResults($in_xml);
  } else {
    ## product finder search
    #my $attribute_set_id = $selected_category->category2cs->first->attribute_set_id;
    my $sth = $edbh->prepare('SELECT attribute_set_id FROM ebay_category_2_cs WHERE category_id = '.$selected_category->{id}) or die $edbh->errstr;
    $sth->execute or die $sth->errstr;
    my $attribute_set_id = $sth->fetchrow_array;

    $stash->{'attribute_set_id'} = $attribute_set_id;
    my $product_finder_id = $param->{'pfid'};
    my $in_xml = "<ProductSearch>
    <AttributeSetID>$attribute_set_id</AttributeSetID>
    <ProductFinderID>$product_finder_id</ProductFinderID>";
    foreach my $attribute_id (keys %{$param}) {
      if($attribute_id =~ /^a[\d]*$/) {
        my $attribute_value = str_safe($param->{$attribute_id});
        $attribute_id =~ s/a//;
        $in_xml .= "
        <SearchAttributes>
          <AttributeID>$attribute_id</AttributeID>
          <ValueList>
            <ValueLiteral>$attribute_value</ValueLiteral>
          </ValueList>
        </SearchAttributes>";
      }
    }
    $in_xml .= "</ProductSearch>";
    my $api = new ebayAPI;
    #open F, "$PATH_TO_STATIC/xml/GetProductSearchResults/sample_pf.xml"; $xml .= $_ while(<F>); close F;
    $xml = $api->getProductSearchResults($in_xml);
  }

  if($xml !~ /An Error Occurred/) {
    my $parser = new XML::Parser (ErrorContext => 2, Style => "Tree");
    my $xmlobj = new XML::SimpleObject ($parser->parse($xml));

    if( $xmlobj->child('GetProductSearchResultsResponse')->child('Ack')->value eq 'Warning' ||
        $xmlobj->child('GetProductSearchResultsResponse')->child('Ack')->value eq 'Failure') {
      $stash->{'error'} = $xmlobj->child('GetProductSearchResultsResponse')->child('Errors')->child('LongMessage')->value;
      $stash->{'error'} =~ s/ <0>//;
    }

    if(not defined $stash->{'error'}) {
      foreach my $product_family ($xmlobj->child('GetProductSearchResultsResponse')->child('ProductSearchResult')->child('AttributeSet')->child('ProductFamilies')) {
        my $product = $product_family->child('ParentProduct');
        if($product) {
          my $product_to_template = {};
          $product_to_template->{'characteristics'} = {};
          foreach my $characteristic ($product->child('CharacteristicsSet')->child('Characteristics')) {
            my ($name, $value) = ('', '');
            $name = $characteristic->child('Label')->child('Name')->value if $characteristic->child('Label');
            $value = $characteristic->child('ValueList')->child('ValueLiteral')->value if $characteristic->child('ValueList');
            $product_to_template->{'characteristics'}->{$name} = $value;
          }
          if($product->child('DetailsURL')) {
            $product_to_template->{'details_url'} = $product->child('DetailsURL')->value;
          }
          my %product_attributes = $product->attributes;
          $product_to_template->{'stock_photo_url'} = $product_attributes{'stockPhotoURL'};
          $product_to_template->{'id'} = $product_attributes{'productID'};
          push @{$stash->{'products'}}, $product_to_template;
        }
      }
    }
  } else {
    $stash->{'error'} = "Product Search Results - Cannot make call to eBay";
  }
  render('product_search_results.tt2');
}

sub get_product_selling_pages {
  prepare_category_tree() if not defined $stash->{'selected_category'};
  my $selected_category = $stash->{'selected_category'};
  prepare_prefilled_cs_form();
  $stash->{'pf'} = 1;
  render('add_item.tt2');
}

##
## builds XML for AddItem call and prints to user
sub add_item {
  $stash->{'pars'} = $param;
  $stash->{'title'} = str_safe($param->{'title'}) || 'Sampe Title';
  $stash->{'subtitle'} = str_safe($param->{'subtitle'}) || '';
  $stash->{'attribute_set_id'} = [param('vcsid')] || '';
  $stash->{'primary_category'} = $param->{'primary_category'} || '';
  $stash->{'start_price'} = $param->{'start_price'} || '5';
  $stash->{'quantity'} = $param->{'quantity'} || 1;
  $stash->{'description'} = str_safe($param->{'description'}) || 'Sample Description';
  $stash->{'item_location'} = str_safe($param->{'item_location'}) || 'Sample Location';
  $stash->{'listing_duration'} = $param->{'listing_duration'} || 'Days_3';
  $stash->{'payment_email'} = str_safe($param->{'payment_email'}) || 'verifyadditem@test.com';
  $stash->{'product_id'} = $param->{'product_id'};

  ## Can save category now. And item attributes will be saved after successful VerifyAddItem call
  if($param->{'primary_category'}) {
    ZOOVY::saveproduct_attrib($USERNAME,$PRODUCT_ID,'ebay:category', $param->{'primary_category'});
  }

  foreach my $attr (keys %$param) {
    if ($attr =~ /^attr/ and $attr !~ /2135_/) { ## 2135 is return policy - we'll process it separately'
      my @attr = split '_', $attr;
      if(param($attr) eq '-6') {
        ## if user selected 'other' and entered his value
        $stash->{'attributes'}{$attr[1]} = str_safe(param('other_'.$attr)) if param('other_'.$attr);
      } else {
        $stash->{'attributes'}{$attr[1]} = [param($attr)] if $attr[1] !~ /\D/ and param($attr);
        $stash->{'attributes'}{$attr[2]} = [param($attr)] if $attr[2] and $attr[2] =~ /^[\d]*$/ and param($attr);
      }
    }
    if ($attr =~ /^cs_name(\d+)/) {
      ## process custom specifics
      if(param('cs_value'.$1)) { ##if value not blank
        push @{$stash->{'custom_specifics'}{param($attr)}}, param('cs_value'.$1);
      }
    }
  }

  if ($param->{'attr2135_3803'}) {
    ## return policy tick enabled - lets process
    $stash->{'ret_policy_attributes'}{3803} = param('attr2135_3803');
    $stash->{'ret_policy_attributes'}{3804} = param('attr2135_3804');
    $stash->{'ret_policy_attributes'}{3805} = param('attr2135_3805');
    $stash->{'ret_policy_attributes'}{3806} = str_safe(param('attr_t2135_3806')) if param('attr_t2135_3806');
  }

  ##$stash->{xml} = 1;
  ##render('item_xml.tt2');
  ## build xml and execute VerifyAddItem to check that there were no errors
  my $item_xml = '';
  my $template = Template->new({ INCLUDE_PATH => $TEMPLATES_PATH });
  $template->process('item_xml.tt2', $stash, \$item_xml);
  my $api = new ebayAPI;
  my $xml = $api->verifyAddItem($item_xml);
  if($xml !~ /An Error Occurred/) {
    my $parser = new XML::Parser (ErrorContext => 2, Style => "Tree");
    my $xmlobj = new XML::SimpleObject ($parser->parse($xml));
    if( $xmlobj->child('VerifyAddItemResponse')->child('Ack')->value eq 'Warning' ||
        $xmlobj->child('VerifyAddItemResponse')->child('Ack')->value eq 'Failure' ) {
      $stash->{'error'} = '<p>'.$xmlobj->child('VerifyAddItemResponse')->child('Errors')->child('ShortMessage')->value . '</p>';
      $stash->{'error'} .= '<p>'.$xmlobj->child('VerifyAddItemResponse')->child('Errors')->child('LongMessage')->value . '</p>';
      $stash->{'error'} .= '<p>Anyway, eBay Category was saved, only selected item specifics were not.</p>';
      render('error.tt2');
    } else {
      ## OK, can save item specifics
      my $item_attributes_xml = '';
      ## will contain both <AttributeSetArray>...</AttributeSetArray> and <ItemSpecifics>...</ItemSpecifics> sections - see template.
      $template->process('item_attributes_xml.tt2', $stash, \$item_attributes_xml);
      if($item_attributes_xml) {
        ZOOVY::saveproduct_attrib($USERNAME,$PRODUCT_ID,'ebay:attributes',$item_attributes_xml);
      }

      #$stash->{xml} = 1;
      #render('item_xml.tt2');
      render('saved.tt2');
    }
  } else {
    $stash->{'error'} = '<p>Error happened while making call to eBay. Sorry.</p>';
    $stash->{'error'} .= '<p>Anyway, eBay Category was saved, only selected item specifics were not.</p>';
    render('error.tt2');
  }
}


##
## saves secondary category (ebay::category2, without item specifics)
sub save_secondary {
  if($param->{'secondary_category'}) {
    ZOOVY::saveproduct_attrib($USERNAME,$PRODUCT_ID,'ebay:category2', $param->{'secondary_category'});
    render('saved.tt2');
  } else {
    render('index.tt2');
  }
}
## END ACTIONS
##

##
## Private Actions here
sub prepare_category_tree {
  my ($categories, $parent_categories, $selected_category);
  if($param->{'id'}) {
    ## extract this category with all children from db
    my $sth = $edbh->prepare("SELECT id, name, leaf, level, parent_id, item_specifics_enabled, product_search_page_available FROM ebay_categories WHERE id = $param->{id}") or die $edbh->errstr;
    $sth->execute or die $sth->errstr;
    my ($cat_id, $cat_name, $cat_leaf, $cat_level, $cat_parent_id, $cat_item_specifics_enabled, $cat_product_search_page_available) = $sth->fetchrow_array;
    $selected_category->{id} = $cat_id;
    $selected_category->{name} = $cat_name;
    $selected_category->{leaf} = $cat_leaf;
    $selected_category->{level} = $cat_level;
    $selected_category->{parent_id} = $cat_parent_id;
    $selected_category->{item_specifics_enabled} = $cat_item_specifics_enabled;
    $selected_category->{product_search_page_available} = $cat_product_search_page_available;
    my $sth1 = $edbh->prepare("SELECT count(id) FROM ebay_categories WHERE parent_id = $cat_id") or die $edbh->errstr;
    $sth1->execute or die $sth->errstr;
    $selected_category->{children_count} = $sth1->fetchrow_array;

    my $category = $selected_category;
    if($category) {
      my $sth = $edbh->prepare("SELECT id, name, leaf, item_specifics_enabled from ebay_categories where parent_id = $param->{id} and id != parent_id") or die $edbh->errstr;
      #my $sth = $edbh->prepare("SELECT b.id, b.name, b.leaf, b.item_specifics_enabled ,count(b.id) FROM `ebay_categories` as a LEFT JOIN `ebay_categories` as b ON b.id=a.parent_id AND b.parent_id=$param->{id} GROUP BY b.id ORDER BY b.name") or die $edbh->errstr;
      $sth->execute or die $sth->errstr;
      while ( my ($cat_id, $cat_name, $cat_leaf, $cat_item_specifics_enabled) = $sth->fetchrow_array ) {
        my $cat = {};
        $cat->{id} = $cat_id;
        $cat->{name} = $cat_name;
        $cat->{leaf} = $cat_leaf;
        $cat->{item_specifics_enabled} = $cat_item_specifics_enabled;
        my $sth1 = $edbh->prepare("SELECT count(id) FROM ebay_categories WHERE parent_id = $cat_id") or die $edbh->errstr;
        $sth1->execute or die $sth->errstr;
        $cat->{children_count} = $sth1->fetchrow_array;
        push @$categories, $cat;
      }

      ## get all parent categories
      push(@$parent_categories, $category) if $category->{level} != 1;
      my $parent_category;
      $sth = $edbh->prepare('SELECT id, name, leaf, item_specifics_enabled, level, parent_id from ebay_categories where id = '.$category->{parent_id}) or die $edbh->errstr;
      $sth->execute or die $sth->errstr;
      my ($cat_id, $cat_name, $cat_leaf, $cat_item_specifics_enabled, $cat_level, $cat_parent_id) = $sth->fetchrow_array;
      my $cat = {};
      $cat->{id} = $cat_id;
      $cat->{name} = $cat_name;
      $cat->{leaf} = $cat_leaf;
      $cat->{item_specifics_enabled} = $cat_item_specifics_enabled;
      $cat->{level} = $cat_level;
      $cat->{parent_id} = $cat_parent_id;
      my $sth1 = $edbh->prepare("SELECT count(id) FROM ebay_categories WHERE parent_id = $cat_id") or die $edbh->errstr;
      $sth1->execute or die $sth->errstr;
      $cat->{children_count} = $sth1->fetchrow_array;
      $parent_category = $cat;
      push(@$parent_categories, $parent_category);

      while($parent_category->{parent_id} != $parent_category->{id}) {
        $category = $parent_category;
        my $sth = $edbh->prepare('SELECT id, name, leaf, item_specifics_enabled, level, parent_id from ebay_categories where id = '.$category->{parent_id}) or die $edbh->errstr;
        $sth->execute or die $sth->errstr;
        my ($cat_id, $cat_name, $cat_leaf, $cat_item_specifics_enabled, $cat_level, $cat_parent_id) = $sth->fetchrow_array;
        my $cat = {};
        $cat->{id} = $cat_id;
        $cat->{name} = $cat_name;
        $cat->{leaf} = $cat_leaf;
        $cat->{item_specifics_enabled} = $cat_item_specifics_enabled;
        $cat->{level} = $cat_level;
        $cat->{parent_id} = $cat_parent_id;
        my $sth1 = $edbh->prepare("SELECT count(id) FROM ebay_categories WHERE parent_id = $cat_id") or die $edbh->errstr;
        $sth1->execute or die $sth->errstr;
        $cat->{children_count} = $sth1->fetchrow_array;
        $parent_category = $cat;
        push(@$parent_categories, $parent_category);
      }
    }
  } else { ## id not defined. extract root category
    #my $sth = $edbh->prepare('SELECT id, name, leaf, item_specifics_enabled from ebay_categories where level = 1') or die $edbh->errstr;
    my $sth = $edbh->prepare("SELECT a.id, a.name, a.leaf, a.item_specifics_enabled, count(b.id) FROM `ebay_categories` as a INNER JOIN `ebay_categories` as b ON b.id=a.parent_id AND b.level=1 GROUP BY b.id ORDER BY a.name") or die $edbh->errstr;
    $sth->execute or die $sth->errstr;
    while ( my ($cat_id, $cat_name, $cat_leaf, $cat_item_specifics_enabled, $cat_children_count) = $sth->fetchrow_array ) {
      my $cat = {};
      $cat->{id} = $cat_id;
      $cat->{name} = $cat_name;
      $cat->{leaf} = $cat_leaf;
      $cat->{item_specifics_enabled} = $cat_item_specifics_enabled;
      $cat->{children_count} = $cat_children_count;
      push @$categories, $cat;
    }
  }
  $stash->{'categories'} = $categories;
  $stash->{'parent_categories'} = $parent_categories;
  $stash->{'selected_category'} = $selected_category;
  1;
}

##
## prepare 'choose category specifics' form
sub prepare_cs_form {
  my $selected_category = $stash->{'selected_category'};

  my $sth = $edbh->prepare('SELECT attribute_set_id FROM ebay_category_2_cs WHERE category_id = '.$selected_category->{id}) or die $edbh->errstr;
  my $rv = $sth->execute or die $sth->errstr;
  my $attr_set_id = $sth->fetchrow_array;

  my $in_xml = "$PATH_TO_STATIC/xml/GetAttributesCS_AttributeData/GetAttributesCS_".$attr_set_id."_AttributeData.xml";
  if(-e $in_xml) {
    my $in_xml_data;
    open(F,$in_xml); $in_xml_data .= $_ while(<F>);  close(F); ## read XML
    $in_xml_data =~ s/<eBay>//;
    my $temp_file = mktemp('/tmp/ebayXXXXXX');
    open(F,">$temp_file");
    print F "<eBay><SelectedAttributes><AttributeSet id='$attr_set_id'/><AttributeSet id='2135'/></SelectedAttributes>", $in_xml_data;
    close(F);
    #my $specifics_html = `xalan -in $temp_file -xsl $PATH_TO_STATIC/xsl/syi_attributes.xsl`;
    my $specifics_html = `$XALAN $temp_file $PATH_TO_STATIC/xsl/syi_attributes.xsl`;
    `rm $temp_file`;
    $specifics_html = fix_dropdown_menus($specifics_html);
    $specifics_html =~ s/var formName = 'APIForm';/var formName = 'add-item-form';/g;
    $specifics_html =~ s/^.*?<form/<form/s;
    $specifics_html =~ s/<\/body>//;
    $specifics_html =~ s/<form.*?>//;
    $specifics_html =~ s/<\/form>//;
    $specifics_html =~ s/color="#000000"/color="#444"/g;
    $specifics_html =~ s/face="Arial, Helvetica, Sans-Serif"//g;
    $specifics_html =~ s/size="2"//g;
    $stash->{'specifics_html'} = $specifics_html;
  }
  1;
}

##
## prepare search page form
sub prepare_sp_form {
  my $selected_category = $stash->{'selected_category'};
  my $sth = $edbh->prepare('SELECT attribute_set_id FROM ebay_category_2_cs WHERE category_id = '.$selected_category->{id}) or die $edbh->errstr;
  $sth->execute or die $sth->errstr;
  my $attribute_set_id = $sth->fetchrow_array;

  my $attributes = [];
  $sth = $edbh->prepare('SELECT ebay_attributes.id, ebay_attributes.name from ebay_attributes, ebay_attribute_set_2_attribute where ebay_attribute_set_2_attribute.attribute_id = ebay_attributes.id AND ebay_attribute_set_2_attribute.attribute_set_id = '.$attribute_set_id) or die $edbh->errstr;
  $sth->execute or die $sth->errstr;
  while ( my ($attr_id, $attr_name) = $sth->fetchrow_array ) {
    my $attr = {};
    $attr->{id} = $attr_id;
    $attr->{name} = $attr_name;
    push(@$attributes, $attr);
  }
  $stash->{'attributes'} = $attributes;
  $stash->{'attribute_set_id'} = $attribute_set_id;
  1;
}

##
## prepare product finder form
sub prepare_pf_form {
  my $selected_category = $stash->{'selected_category'};
  my $category_id = $selected_category->{id};
  #my $product_finder_id = $selected_category->category2pf->first->product_finder_id;
  my $sth = $edbh->prepare('SELECT ebay_product_finders.id FROM ebay_category_2_product_finder, ebay_product_finders WHERE ebay_product_finders.id = ebay_category_2_product_finder.product_finder_id AND ebay_category_2_product_finder.category_id = '.$selected_category->{id}) or die $edbh->errstr;
  $sth->execute or die $sth->errstr;
  my $product_finder_id = $sth->fetchrow_array;
  ##prepare product finder form
  my $in_xml = "$PATH_TO_STATIC/xml/GetProductFinder_ProductFinderData/GetProductFinder_".$product_finder_id."_ProductFinderData.xml";
  if(-e $in_xml) {
    my $in_xml_data;
    open(F,$in_xml); $in_xml_data .= $_ while(<F>);  close(F); ## read XML
    my $temp_file = mktemp('/tmp/ebayXXXXXX');
    open(F,">$temp_file"); print F $in_xml_data; close(F);
    #my $html = `xalan -in $temp_file -xsl $PATH_TO_STATIC/xsl/product_finder.xsl`;
    my $html = `$XALAN $temp_file $PATH_TO_STATIC/xsl/product_finder.xsl`;
    $html =~ s/var formName = 'APIForm';/var formName = 'pf-form';/g;
    `rm $temp_file`;
    $html =~ s/<\/form>/<input type="hidden" id="category_id" name="id" value="$category_id" \/><\/form>/g;
    $html =~ s/action="PFPage"/action="\/biz\/ebay\/catchooser2008\/index.cgi\/get_product_search_results"/g;
    $html =~ s/id="tmppfform"/id="pf-form"/;
    $html =~ s/<form method="post"/<form method="post" id="pf-form"/;
    $stash->{'product_finder_html'} = $html;
  }
  1;
}

##
## prepare prefilled item specifics form
sub prepare_prefilled_cs_form {
  my $selected_category = $stash->{'selected_category'};
  my $product_id = $param->{'product_id'};
  my $attribute_set_id = $param->{'attribute_set_id'};

  my $api = new ebayAPI;
  my $xml = $api->getProductSellingPages($product_id, $attribute_set_id);

  if($xml !~ /An Error Occurred/) {
    my $parser = new XML::Parser (ErrorContext => 2, Style => "Tree");
    my $xmlobj = new XML::SimpleObject ($parser->parse($xml));

    ## parse response
    $xml = $xmlobj->child('GetProductSellingPagesResponse')->child('ProductSellingPagesData')->value;
    $xmlobj = new XML::SimpleObject ($parser->parse($xml));
    $stash->{'product_title'} = $xmlobj->child('Products')->child('Product')->child('ProductInfo')->child('Title')->value;
    $xml =~ s/.*?<Attributes>/<Attributes>/sm;
    $xml =~ s/<\/Product>\n//;
    $xml =~ s/<\/Products>/<\/eBay>/;
    $xml = "<eBay><SelectedAttributes><AttributeSet id='$attribute_set_id'/><AttributeSet id='2135'/></SelectedAttributes>" . $xml;

    ## apply xsl
    my $temp_file = mktemp('/tmp/ebayXXXXXX');
    open F, ">$temp_file"; print F $xml; close F;
    #my $specifics_html = `xalan -in $temp_file -xsl $PATH_TO_STATIC/xsl/syi_attributes.xsl`;
    my $specifics_html = `$XALAN $temp_file $PATH_TO_STATIC/xsl/syi_attributes.xsl`;
    `rm $temp_file`;
    $specifics_html = fix_dropdown_menus($specifics_html);
    $specifics_html =~ s/var formName = 'APIForm';/var formName = 'add-item-form';/g;
    $specifics_html =~ s/^.*?<form/<form/s;
    $specifics_html =~ s/<\/body>//;
    $specifics_html =~ s/<form.*?>//;
    $specifics_html =~ s/<\/form>//;
    $specifics_html =~ s/color="#000000"/color="#444"/g;
    $specifics_html =~ s/face="Arial, Helvetica, Sans-Serif"//g;
    $specifics_html =~ s/size="2"//g;
    $stash->{'specifics_html'} = $specifics_html;
    $stash->{'product_id'} = $product_id;
  } else {
    $stash->{'error'} = 'Prefilled Attributes Form - cannot make call to eBay';
  }
  1;
}

## makes ugly eBay dropdown menus javascript work.
sub fix_dropdown_menus {
  my $html = shift;
  ## disable form autosubmit on dropdown change
  $html =~ s/(aus_form\.submit\(\);)/\/\/$1/g;
  $html =~ s/(document\.forms\[formName\]\.submit\(\);)/\/\/$1/;
  ## fix dropdown
  my $search_str = qr/<select\sonChange="aus_set_parent\('.*?',1\);api_check_on_other\('.*?',this\.value\);"/;
  my $replace_template = qq/<select onChange="aus_set_parent('xxxxxx',1);api_check_on_other('xxxxxx',this.value);aus_init_cascades('xxxxxx',1);display_input_for_other(this,'xxxxxx', this.value);"/;
  my $search_str1 = qr/<select\sonChange="api_check_on_other\('.*?',this\.value\);"/;
  my $replace_template1 = qq/<select onChange="api_check_on_other('xxxxxx',this.value);display_input_for_other(this,'xxxxxx', this.value);"/;
  $html =~ /aus_init_cascades\("(.*?)",1\);/;
  my $par = $1;
  $replace_template =~ s/xxxxxx/$par/g;
  $replace_template1 =~ s/xxxxxx/$par/g;
  $html =~ s/$search_str/$replace_template/g;
  $html =~ s/$search_str1/$replace_template1/g;

  return $html;
}
## Private Actions END
##

## Dispatcher
##
sub dispatch {
  $dispatch->{'index'} = \&index;
  $dispatch->{'logout'} = \&logout;
  $dispatch->{'get_categories'} = \&get_categories;
  $dispatch->{'get_suggested_categories'} = \&get_suggested_categories;
  $dispatch->{'describe_item'} = \&describe_item;
  $dispatch->{'show_sp_pf_form'} = \&show_sp_pf_form;
  $dispatch->{'show_sp_form'} = \&show_sp_form;
  $dispatch->{'show_pf_form'} = \&show_pf_form;
  $dispatch->{'get_product_search_results'} = \&get_product_search_results;
  $dispatch->{'get_product_selling_pages'} = \&get_product_selling_pages;
  $dispatch->{'add_item'} = \&add_item;
  $dispatch->{'save_secondary'} = \&save_secondary;

  if ((defined $action) and (defined $dispatch->{$action})) {
    $dispatch->{$action}();
  } else {
    $dispatch->{'index'}();
  }
}

