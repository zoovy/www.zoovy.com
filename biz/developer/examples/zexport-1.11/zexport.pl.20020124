#!/usr/bin/perl -w

## zexport.pl
## 
## purpose: a simple content replacement system which integrates with the Zoovy products database.
##
## comments;
## this uses it's own HTML and SGML processor, mainly because the HTML libraries which are included with perl tend to be very heavy
## to run, hard to install and are generally not found on most ISP's boxes, in addition by using regex's we have much superior 
## control for working around [ignoring] broken HTML.
##
## release history:
##		version 1.0	9/24/01	
##		version 1.1	1/23/02	- Cleaned up syntax for main loop, etc.
##		version 1.11	1/24/02	- Added support for images for add to cart button
## 	
##	todo/known bugs:
##		doesn't support inventory, merchant, channel, or crypt namespaces (yet).
## 	has legacy reference to fetch_productattrib
##		needs documentation towards the bottom of the file.
##
## additional notes:
## 	LWP and HTTP are only required if running in modes 0/1, you could alternatively use something like lynx 
##		or virtually any HTTP capable program to download the Zoovy products database from the URL specified below.
##
use LWP::UserAgent;						
use HTTP::Request::Common;

#################################
#### CONFIGURATION PARAMETERS
#################################
$ZOOVY_USERNAME = "brian"; # this is your Zoovy Username
$ZOOVY_PASSWORD = "password"; # this is your Zoovy Password
$PROGRAM_NAME = "zexport/1.11"; # please leave this alone. (it's the useragent)

$addtocartbuttonurl = ''; # Change this to the location of an image to use for the add to card button

$RUN_MODE = 2;
# 0 means always retrieve a fresh copy of products.zoovy
# 1 means load a fresh copy, but save to CACHED_PRODUCTS file for debug
# 2 means always use the local copy of CACHED_PRODUCTS (handy for debuggin!)

$CACHED_PRODUCTSDB = 'samples/products.zoovy'; 
# this is the path+filename the exported Zoovy products database will
# be stored at, make sure this file is writeable by the user running zexport!

$DEBUG = 0; # enable for verbose messages

$SRC_FILES = "samples/files.txt"; # list of files to process for input

#################################
#### GLOBAL VARIABLES
#################################
my $proddbref = undef;
# eventually contains a reference to a hash keyed by product id,
# which contains a reference to another hash that has key/value pairs for
# for product attributes

# Let get started, first determine if we are running off a local or remote copy of the data.
if ($RUN_MODE<2) {

	# alternative syntax (to always load from a local file)
	# $request = HTTP::Request->new('GET', 'file://localhost/tmp/products.zoovy');
	$requesturi = "http://www.zoovy.com/webapi/merchant/productsync.cgi?METHOD=DOWNLOADSINCE&TIMESTAMPS=0&USERNAME=$ZOOVY_USERNAME&PASSWORD=$ZOOVY_PASSWORD";
	if ($DEBUG) { print "Downloading $requesturi\n"; }

	my $agent = new LWP::UserAgent;
	$agent->agent($PROGRAM_NAME);

	$result = $agent->request(GET $requesturi);
	
	if ($result->content_type =~ /error/i) {
		die ("Could not access $requesturi");
	}

	if ($DEBUG>1) { print "Retrieved ".length($result->content())." bytes.\n"; }

	if ($RUN_MODE==1) {
		open F, ">$CACHED_PRODUCTSDB" || die "Could not open $CACHED_PRODUCTSDB for writing.";	
		print F $result->content();
		close F;
	}
	$proddbref = &process_products_db(\$result->content());

}
elsif ($RUN_MODE == 2) {

	local $/ = undef;
	open F, "<$CACHED_PRODUCTSDB" || die "Could not open $CACHED_PRODUCTSDB for reading.";
	my $buffer = <F>;
	close F;
	$/ = "\n";
	if ($DEBUG>1) { print "Retrieved ".length($buffer)." bytes from file=[$CACHED_PRODUCTSDB]\n"; }
	$proddbref = &process_products_db(\$buffer);

}
## at this point, $

## read in the list of files to process
open F, "<$SRC_FILES" || die "Could not find $SRC_FILES for reading to retrieve list of files to process\n";
my @files = <F>;
close F;
if ($DEBUG>1) { print "Found ".scalar(@files)." files to process in files.txt.\n"; }

foreach $file (@files) {

	if ($DEBUG) { print "Processing $file\n"; }

	# read the file into $buffer
	local $/ = undef; # Set input separator to blank to read in entire file
	open F, "<$file" || die "Unable to open $file for reading.";
	my $buffer = <F>;
	close F; 
	$/ = "\n"; # Reset input separator to newline

	# at this point $buffer has the contents of $file
	$output = '';
	foreach my $chunk (split(/(<ZOOVY.*?<\/ZOOVY>)/s,$buffer)) {
		if ($chunk =~ /\<ZOOVY(.*?)\>.*?\<\/ZOOVY\>/s) {
			## this code is run if we have a ZOOVY TAG
		 	if ($DEBUG>5) { print "FOUND CHUNK $chunk\n"; }
			$output .= &interpret_chunk($1);
		
		}
		else {
			# this code is run if we don't have a ZOOVY tag
			$output .= $chunk;
		}
	}
	
	# at this point $output is the output we will show to the browser
	if ($DEBUG>1) { print $output."\n"; }

	open F, ">$file" || die "Unable to open $file for writing.";
	print F $output;
	close F;

} # end of foreach file

exit;

############################################################
##
## function: interpret_chunk
## version: 1.0 9/24/01 BH
## purpose: accepts the contents found inside the <ZOOVY ...> tag and trys to make sense of the whole mess
## returns: the resulting HTML
## 
## valid types:
##		TEXT -> SRC, PRODUCT
##		IMAGE -> SRC, PRODUCT, HEIGHT, WIDTH
##		ADDCART -> PRODUCT
##
## note: this assumes the global $proddbref has already been setup
##
############################################################
sub interpret_chunk {

	my ($attribs) = @_;	
	my $output = '';
	my %keyvals = ();

	# convert attribs into key value pairs
	foreach my $kv (split(/ /,$attribs)) {
		if ($kv =~ /(.*?)=\"(.*?)\"/) {
			$keyvals{uc($1)} = $2;
		}
	}
	
	# at this point %keyvals  contains a list of key value pairs, the most important is TYPE which determines
	# where we go from here.
	
	$output .= '<ZOOVY'.$attribs.'>';
	if ($keyvals{'TYPE'} eq 'TEXT') {
		$datafromsrc = &smartload($keyvals{'SRC'},$keyvals{'PRODUCT'});
		if (!defined($datafromsrc)) { $datafromsrc = $keyvals{'DEFAULT'}; }
		if (!defined($datafromsrc)) { $datafromsrc = ''; }
		$output .= $datafromsrc;
	} 
	elsif ($keyvals{'TYPE'} eq 'IMAGE') {
		$datafromsrc = &smartload($keyvals{'SRC'},$keyvals{'PRODUCT'});
		if (!defined($datafromsrc)) { $datafromsrc = $keyvals{'DEFAULT'}; }
		if (!defined($datafromsrc)) { $datafromsrc = ''; }
		if (!defined($keyvals{'HEIGHT'})) { $keyvals{'HEIGHT'} = 100; }
		if (!defined($keyvals{'WIDTH'})) { $keyvals{'WIDTH'} = 100; }
		if (!defined($keyvals{'BGCOLOR'})) { $keyvals{'BGCOLOR'} = FFFFFF; }
		$output .= "<img src=\"";
		$output .= &imageurl($ZOOVY_USERNAME,$datafromsrc,$keyvals{'HEIGHT'},$keyvals{'WIDTH'},$keyvals{'BGCOLOR'},0);
		$output .= "\" width=\"$keyvals{'WIDTH'}\" height=\"$keyvals{'HEIGHT'}\" border=\"0\">";
	}
	elsif ($keyvals{'TYPE'} eq 'ADDCART') {
		$output .= &addtocartbutton($keyvals{'PRODUCT'},$addtocartbuttonurl);
	} 
	else {
		die "Encountered unknown TYPE in chunk [$attribs]\n";
	}
	$output .= '</ZOOVY>';
	return($output);
}

############################################################
##
## function: smartload
## note: assumes $proddbref has already been setup, no sense passing something which really ought to be global.
##
############################################################
sub smartload {

	my ($SRC,$PRODUCTID) = @_;
	my ($location,$tag) = split(':',uc($SRC),2);
	if ($location eq 'PRODUCT') {
		if (!defined($proddbref->{$PRODUCTID}->{$tag})) {
			return undef;
		} 
		else {
			return $proddbref->{$PRODUCTID}->{$tag};
		}
	}
	else {
		die "Smart Load Failed! SRC=[$SRC] PRODUCT=[$PRODUCTID]";
	}

}


############################################################
##
## function: process_products_db
## version: 1.0 9/24/01 BH
## parameters: accepts a reference to a scalar that contains the plaintext buffer
## purpose: parses through a zml products file, then returns a reference to a hash containing the products
## returns: a reference to a hash that looks like this
##
############################################################
sub process_products_db {

	my ($bufferref) = @_;
	%hash = ();
	foreach  $chunk (split(/\<\/PRODUCT\>/s,${$bufferref})) {
		if ($chunk =~ /^\<PRODUCT NAME\=\"(.*?)\".*?\>(.*)$/s) {
			$prodid = $1;
			$data = $2;
			$hash{$prodid} = &attrib_handler_ref(\$data);
		} 
	}	# end of foreach $chunk loop

	return \%hash;
}


##########
#
# ZOOVY::dcode
#
# parameters: a buffer that needs to be decoded.
# returns: $BUFFER
#
###########
sub dcode {

	my ($BUFFER) = @_;
	if (not defined $BUFFER) { return undef; }
	$BUFFER =~ s/\&gt\;/\>/g; 	
	$BUFFER =~ s/\&lt\;/\</g;
	$BUFFER =~ s/\&quot\;/\"/g;
	$BUFFER =~ s/\&amp\;/\&/g;

	return $BUFFER;
}


##############################
## 
## sub: attrib_handler_ref
##
## PURPOSE: converts strings from the format <merchant.tag>data</tag> to 
##          a usable hash
##
## returns: HASH reference with key=merchant.tag and value=data
##
###############################
sub attrib_handler_ref {

	my ($BUFFERREF, $HASHREF) = @_;
	# If we weren't passes a reference to a hash, make a new one
	if (not defined ($HASHREF)) { $HASHREF = {}; }
	if ((not defined ($BUFFERREF)) || (${$BUFFERREF} eq '')) { return undef; }

	# first match all the merchant:tag combinations (note this will NOT
	# match </merchant:attrib>
	${$BUFFERREF} .= "\n";
	study(${$BUFFERREF});

	# split on the end tags.
	my @ar = split(/(.*?)<\/([\w]+\:[\w]+)\>(.*?)/s,${$BUFFERREF});
    
	foreach my $KEY (@ar) {
		next if ($KEY eq '');
		# find the data which matches the KEY
		if ($KEY =~ /.*?([\w]+\:[\w]+).*?/is) {
			$KEY = $1;
			if (${$BUFFERREF} =~ /\<$KEY\>(.*?)\<\/$KEY\>/si) { 
				$HASHREF->{uc($KEY)} = &dcode($1); 
			}
			else {
				print STDERR "Unbalanced key: $KEY\n";
			}
		} # end of if internal key match
	} # end of foreach $KEY

	return $HASHREF;
}

###########################################################################
## imageurl
## handles imagelib/legacy (absolute URL) conversion 
## parameters: USERNAME, variable, height, width, background, ssl
## 
sub imageurl {

	my ($USERNAME, $var, $h, $w, $bg, $ssl) = @_;

	if (!defined($h)) { $h = 100; }
	if (!defined($w)) { $w = 100; }
	if (!defined($bg)) { $bg = 'FFFFFF'; }
	if (!defined($bg)) { $ssl = 0; }

	if ($DEBUG) { print STDERR "GT::imageurl received [$USERNAME] [$var] [$h] [$w] [$bg] [$ssl]\n"; }

	# if we don't have an image, pass that along.
	if (!defined($var)) { return undef; }	
	if ($var eq "") { return undef; } 

	# check for legacy
	if ($var !~ /^http/i) {
		# is from imagelibrary
		if (!defined($bg)) { $bg = "FFFFFF"; }

		if ( (int($h)==0) && (int($w)==0) ) {
			$var = "http://static.zoovy.com/img/$USERNAME/-/$var";
		}
		else {
			$var = "http://static.zoovy.com/img/$USERNAME/H$h-W$w-B$bg/$var";
		}
	}


	if (defined($ssl) && $ssl) { $var =~ s/http\:/https\:/i; }
	else { $var =~ s/https\:/http\:/i; }

	return $var;
}

#######################################
## Takes a pog (Product Option Group) contents and converts it to HTML
##
sub pog_to_html {
	 ($BUFFER) = @_;
	my @ar2 = ();
	$BUFFER .= "crap";
	my @ar = split(/<\/option>/i,$BUFFER);
	pop @ar;
	foreach my $opt (@ar) {
		my $VALUE = "";
		my $PROMPT = "";
		my $PRICE = "";
		if ($opt =~ /value=\"(.*?)\"/i) { $VALUE = $1; }
		if ($opt =~ /<option.*?>(.*?)$/i) {
			my $TEMP = $1;
			$TEMP =~ s/\_/ /g;
			foreach (split/\s/,$TEMP) {
				$PROMPT = $PROMPT . ucfirst($_) . ' ';
			}
			$PROMPT =~ s/\s+$//;
			$PROMPT =~ s/^\s+//;
		}
		if ($opt =~ /price=\"(.*?)\"/i) { $PRICE = $1; }
		if (($PRICE ne "") && ($PRICE != 0)) {
			my $mathsym = "";
			if (index($PRICE,"+")>=0) { $mathsym = '+'; }
			if (index($PRICE,"-")>=0) { $mathsym = '-'; }
			#if ($mathsym eq "") { $mathsym = "+"; }
			if (index($PRICE,"\%")>=0) { $type = "\%"; }
			else { $type = "\$"; }
			$PRICE =~ s/[^0-9|^\.]//g;
			if ($type eq "\$") { $PRICE = $mathsym.$type.(sprintf("%.2f",$PRICE)); } 
			else { $PRICE = $mathsym.$type.$PRICE; } 
			$PRICE = "($PRICE)";	
			# instead of going straight to html, lets push it into an array which can be sorted 
			# note: it will sort by value since that comes first, all things being equal
			push @ar2, "<option value='$VALUE'>$PROMPT $PRICE</option>";
		}
		else {
			push @ar2, "<option value='$VALUE'>$PROMPT</option>";
		}
	}

	# sort and covert the result array into a html buffer which we return
	return join('',sort @ar2);
}


######################################################################
## this is simply an alias to smart load
## put in here because i'm really lazy and didn't want to re-write 
## addtocartbutton completely.
sub fetchproduct_attrib
{
	return(smartload('product:'.$_[2],$_[1]));
}


##################################
## addtocartbutton
## takes a product id and an image name (optional) to use for the button
## returns: the html code to generate a add to cart button for the named ZOOVY_USERNAME
##
sub addtocartbutton {

	my ($PRODUCTID,$USEIMG) = @_;

	my $nonsecure_root = "http://$ZOOVY_USERNAME.zoovy.com";

	# Get the pogs associated with the product
	my $pogs = &smartload('product:$ZOOVY_USERNAME:pogs',$PRODUCTID);
	if (not defined $pogs) { $pogs = ''; }
		my @pog_list = ();
		my (%pog_prompts, %pog_options);
		foreach $pog (split /\,/, $pogs) {
			push @pog_list, $pog;
			$pog_prompts{$pog} = $pog;
			$pog_prompts{$pog} =~ s/ //ig;
			$pog_prompts{$pog} =~ s/_/ /ig;
			$pog_prompts{$pog} = &pretty($pog_prompts{$pog});
			$pog_options{$pog} = &pog_to_html("product:$ZOOVY_USERNAME:pog_$pog",$PRODUCTID);
		}

	# See if we need to display a notes field
	$notes_display = &fetchproduct_attrib($ZOOVY_USERNAME,$PRODUCTID,"zoovy:notes_display");
	if (not defined $notes_display) { $notes_display = 0; }

	if ($notes_display) {
		$notes_prompt = &fetchproduct_attrib($ZOOVY_USERNAME,$PRODUCTID,"zoovy:notes_prompt");
		if ((not defined $notes_prompt) || (not $notes_prompt)) { $notes_prompt = "Notes"; }
		$notes_default = &fetchproduct_attrib($ZOOVY_USERNAME,$PRODUCTID,"zoovy:notes_default");
		if (not defined $notes_default) { $notes_default = ""; }
	}

	$imgtag = '';
	if (defined($USEIMG) && $USEIMG) {
		$imgtag = "<input type=\"image\" src=\"$USEIMG\" border=\"0\" alt=\"Add to Cart\">";
	}

	$code = "<form action=\"$nonsecure_root/cart.cgis\" method=\"get\">\n";
	$code = "<input type=\"hidden\" name=\"product_id\" value=\"$PRODUCTID\">\n";
	$code = "<input type=\"hidden\" name=\"add\" value=\"yes\">\n";
	$code = "<input type=\"hidden\" name=\"pogs\" value=\"$pogs\">\n";

	if (scalar @pog_list) {
		$code .= "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n";
		foreach $pog (@pog_list) {
			$code .= "	<tr>\n";
			$code .= "		<td align=\"right\" valign=\"middle\"><b>$pog_prompts{$pog}:</b></td>\n";
			$code .= "		<td align=\"left\" valign=\"middle\">&nbsp;\n";
			$code .= "			<select name=\"pog_$pog\">\n";
			$code .= "			$pog_options{$pog}\n";
			$code .= "			</select>\n";
			$code .= "		</td>\n";
			$code .= "	</tr>\n";
		}
		$code .= "</table>\n";
		$code .= "<br>\n";
	}
	if ($notes_display) {
		$code .= "<b>$notes_prompt:</b><br>\n";
		$code .= "<input type=\"hidden\" name=\"notes_prompt\" value=\"$notes_prompt\">\n";
		$code .= "<textarea cols=\"35\" rows=\"7\" name=\"notes\" wrap=\"soft\">$notes_default</textarea><br>\n";
		$code .= "<br>\n";
	}
	if ($imgtag) {
		$code .= "$imgtag\n";
	}
	else {
		$code .= "<input type=\"submit\" value=\"Add to Cart\">\n";
	}
	$code .= "</form>\n";

	return($code);
}
