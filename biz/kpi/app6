package SYNDICATION;

use Carp;
use UNIVERSAL;
use YAML::Syck;
use Class::Runtime;
use strict;

use lib "/httpd/modules";
use base 'LISTING::MSGS';

require DBINFO;
require ZTOOLKIT;
require ZWEBSITE;
require ZOOVY;
require NAVCAT::FEED;
require TODO;
require WHOLESALE;
require INVENTORY;
require SITE;
require MEDIA;
require PRODUCT::STASHES;
require PRODUCT::BATCH;
require LISTING::MSGS;
##
use Data::Dumper;
use Archive::Zip;

##
## IS_ACTIVE (bitwise)
##		1 = yes (required)
##		2 = test bit (only simulate, don't actually transfer)
##		4 = don't archive files
##		64 = don't submit products
##

##
## DSTCODES are:
##		AMZ - Amazon
##		BUY - buy.com
##		BSF - buysafe
##		EBS - EBAY Stores
##		GOO - Google Shopping / Froogle
##		BZR - Bizrate / Shopzilla
##

##
## add to webdoc:

##		[[MASON]]
##		% use SYNDICATION;
##		% print SYNDICATION::webdoc_panel("SHO"); 
##		[[/MASON]]
##
sub webdoc_panel {
	my ($dstcode) = @_;

	my $info = $SYNDICATION::PROVIDERS->{uc($dstcode)};
	
	return(Dumper($info));
	}



##
## this is going to eventually replace SYNDICATION::DSTCODES .. but I use it to keep
##	track of which ones i've started or finished moving over to app6:/httpd/servers/customfeed/batch.pl
##
##	module is the name of the /httpd/modules/SYNDICATION/module.pm file. 
##
%SYNDICATION::PROVIDERS = (
	'SRS'=>{
		title=>'Sears',
		},
	'BCM'=>{
		title=>'Become.com',
		module=>'BECOME',
		linkmeta=>'BECOME',
		syndicationOPTIONs=>1,
		source=>'WEBSITE-META',
		navcatMETA=>'BCM',
      analytics_utm_source=>'BECOME',
      analytics_utm_content_var=>'become:content',
      analytics_utm_campaign_var=>'become:campaign',		
		category_webdoc=>51553,
		attrib=>'become:ts',
		},
	'SMT'=>{
		title=>'Smarter.com',
		module=>'SMARTER',
		linkmeta=>'SMARTER',
		syndicationOPTIONs=>1,
		source=>'PRODUCTS-ALL',
		navcatMETA=>'SMT',
      analytics_utm_source=>'SMARTER',
      analytics_utm_content_var=>'smarter:content',
      analytics_utm_campaign_var=>'smarter:campaign',		
		category_webdoc=>51558,
		attrib=>'smarter:ts',
		},
	'DIJ'=>{
		title=>'DijiPop.com',
		module=>'DIJIPOP',
		linkmeta=>'DIJIPOP',
		syndicationOPTIONs=>1,
		source=>'PRODUCTS-ALL',
		category_webdoc=>0,
		attrib=>'dijipop:ts',
		},
	'LNK'=>{
		title=>'LinkShare.com',
		module=>'LINKSHARE',
		linkmeta=>'LINKSHARE',
		syndicationOPTIONs=>1,
		source=>'PRODUCTS-ALL',
      analytics_utm_source=>'LINKSHARE',
      analytics_utm_content_var=>'linkshare:content',
      analytics_utm_campaign_var=>'linkshare:campaign',		
		category_webdoc=>0,
		attrib=>'linkshare:ts',
		},
	'FND'=>{
		title=>'TheFind.com',
		module=>'THEFIND',
		linkmeta=>'THEFIND',
		syndicationOPTIONs=>1,
		source=>'PRODUCTS-ALL',
      analytics_utm_source=>'THEFIND',
      analytics_utm_content_var=>'thefind:content',
      analytics_utm_campaign_var=>'thefind:campaign',		
		category_webdoc=>51516,
		attrib=>'thefind:ts',
		},
	'PTO'=>{
		title=>'Pronto.com',
		module=>'PRONTO',
		linkmeta=>'PRONTO',
		syndicationOPTIONs=>1,
		source=>'WEBSITE-META',
		navcatMETA=>'PRONTO_CAT',
      analytics_utm_source=>'PRONTO',
      analytics_utm_content_var=>'pronto:content',
      analytics_utm_campaign_var=>'pronto:campaign',
		category_webdoc=>51520,
		attrib=>'pronto:ts',
		},
	'IMS'=>{
		title=>'Imshopping.com',
		module=>'IMSHOPPING',
		linkmeta=>'IMSHOPPING',
		source=>'WEBSITE-ALL',
		syndicationOPTIONs=>1,
      analytics_utm_source=>'IMSHOPPING',
      analytics_utm_content_var=>'imshopping:content',
      analytics_utm_campaign_var=>'imshopping:campaign',
		attrib=>'imshopping:ts',
		},
	'WSH'=>{
		title=>'Wishpot.com',
		module=>'WISHPOT',
		linkmeta=>'WISHPOT',
		source=>'WEBSITE-ALL',
		analytics_utm_source=>'WISHPOT',
		analytics_utm_content_var=>'wishpot:content',
		analytics_utm_campaign_var=>'wishpot:campaign',		
		attrib=>'wishpot:ts',
		},
	'VRT'=>{
		title=>'Veruta.com',
		module=>'VERUTA',
		linkmeta=>'VERUTA',
		source=>'WEBSITE-ALL',
		analytics_utm_source=>'VERUTA',
		analytics_utm_content_var=>'veruta:content',
		analytics_utm_campaign_var=>'veruta:campaign',
		attrib=>'veruta:ts',
		},
	'SDT'=>{
		title=>'Shop.com',
		attrib=>'shopdot:ts',
		},
	'SHO'=>{
		title=>'Shopping.com',
		module=>'SHOPPINGCOM',
		attrib=>'shopping:ts',
		# allowed=>'shopping:allowed',
		syndicationOPTIONs=>1,
		navcatMETA=>'SHO',
		expandPOGs=>2,
		source=>'WEBSITE-META',
		linkmeta=>'shopping',
		analytics_utm_source=>'SHOPCOM',
		analytics_utm_content_var=>'shopping:content',
		analytics_utm_campaign_var=>'shopping:campaign',
		category_webdoc=>51524,
		},
	'CJ'=>{
		title=>'Commission Junction',
		module=>'CJUNCTION',
		# allowed=>'cj:allowed',
		attrib=>'cj:ts',
		syndicationOPTIONs=>1+4,
		navcatMETA=>'CJ',
		expandPOGs=>2,
		source=>'WEBSITE-ALL',
		validationLogPlease=>1,
		},
	'OAS'=>{
		title=>'Overstock Auction Syndication',
		attrib=>'overstock:ts',
		module=>'OVERSTOCK',
		navcatMETA=>'OS_CAT',
		source=>'WEBSITE-META',
		syndicationOPTIONs=>2,
		},
	'ESS'=>{
		title=>'eBay Store',
		attrib=>'ebaystores:ts',
		module=>'EBAYSTORE',
		navcatMETA=>'EBAY_CAT',
		syndicationOPTIONs=>2,
		source=>'WEBSITE-EBAY',
		stashable=>1,
		},
	'BIN'=>{
		title=>'BING/Microsoft Cashback',
		attrib=>'bing:ts',
		syndicationOPTIONs=>1+4,
		# allowed=>'bing:allowed',
		module=>'BING',
		navcatMETA=>'BIN',
		linkmeta=>'BING',
		analytics_utm_source=>'BINGCB',
		analytics_utm_content_var=>'bing:content',
		analytics_utm_campaign_var=>'bing:campaign',
		expandPOGs=>2,
		validationLogPlease=>1,
		category_webdoc=>51526,
		source=>'WEBSITE-META',
		},
	#'EBS'=>{
	#	title=>'eBay.com syndication',
	#	navcatMETA=>'EBAYSTORE_CAT',
	#	attrib=>'ebay:ts',
	#	},
 	'GOO'=>{
 		title=>'GoogleBase',
		attrib=>'gbase:ts',
      syndicationOPTIONs=>1,	
 		module=>'GOOGLEBASE',
		navcatMETA=>'GOOGLEBASE',
		expandPOGs=>1,
		validationLogPlease=>1,
		analytics_utm_source=>'gbase',
		linkmeta=>'GBASE',
		analytics_utm_content_var=>'gbase:content',
		analytics_utm_campaign_var=>'gbase:campaign',
		category_webdoc=>51521,
		source=>'WEBSITE-ALL',
 		},
	'GSM'=>{
		title=>'Google Site Map',
		module=>'GOOGLESITEMAP',
		headerOnly=>1,
		source=>'WEBSITE-ALL',
		link=>'/biz/syndication/sitemap/?VERB=EDIT&PROFILE=%PROFILE%',
		},
   'BSS'=>{
      title=>"BuySafe",
      module=>'BUYSAFE',
		linkmeta=>'buysafe',
      syndicationOPTIONs=>1,	
		analytics_utm_source=>'BUYSAFE',
		analytics_utm_content_var=>'buysafe:content',
		analytics_utm_campaign_var=>'buysafe:campaign',
		link=>'/biz/syndication/buysafe/?VERB=EDIT&PROFILE=%PROFILE%',
      },
   'PRV'=>{
      title=>'PowerReviews',
      module=>'POWERREV',
      },
	'BZR'=>{
		title=>'BizRate',
		module=>'BIZRATE',
		attrib=>'bizrate:ts',
		navcatMETA=>'BIZRATE_CAT',
		linkmeta=>'bizrate',
      syndicationOPTIONs=>1,	
		analytics_utm_source=>'BIZRATE',
		analytics_utm_content_var=>'bizrate:content',
		analytics_utm_campaign_var=>'bizrate:campaign',
		expandPOGs=>2,
		link=>'/biz/syndication/bizrate/?VERB=EDIT&PROFILE=%PROFILE%',
		},
	'PGR'=>{
		title=>'PriceGrabber',
		module=>'PRICEGRAB',
		attrib=>'pricegrabber:ts',
		syndicationOPTIONs=>1,
		navcatMETA=>'PRICEGRABBER',
		linkmeta=>'pricegrabber',
		analytics_utm_source=>'PRICEGRAB',
		analytics_utm_content_var=>'pricegrabber:content',
		analytics_utm_campaign_var=>'pricegrabber:campaign',
		category_webdoc=>51523,
		link=>'/biz/syndication/pricegrabber/?VERB=EDIT&PROFILE=%PROFILE%',
		source=>'WEBSITE-ALL',
		},
   'BUY'=>{
		use_inventory=>1,
      title=>'BUY.com',
      module=>'BUYCOM',
		attrib=>'buycom:ts',
		stashable=>1,
		expandPOGs=>1,
		validationLogPlease=>1,
		link=>'/biz/syndication/buycom/?VERB=EDIT&PROFILE=%PROFILE%',
		source=>'PRODUCTS-ALL',
      },
#	'YST'=>{
#		title=>'Yahoo Shopping',
#		module=>'YAHOOSHOP',
#		attrib=>'yshop:ts',
#		navcatMETA=>'YSHOP_CAT',
#		syndicationOPTIONs=>1,		## 
#		linkmeta=>'yahooshop',
#		analytics_utm_source=>'YAHOOSHOP',
#		analytics_utm_content_var=>'yshop:content',
#		analytics_utm_campaign_var=>'yshop:campaign',
#		},
	'SAS'=>{
		title=>'Share-A-Sale',
		module=>'SHAREASALE',
		attrib=>'sas:ts',
		navcatMETA=>'SAS_CAT',
		syndicationOPTIONs=>1,		## 
		linkmeta=>'sas',
		analytics_utm_source=>'SAS',
		analytics_utm_content_var=>'sas:content',
		analytics_utm_campaign_var=>'sas:campaign',
		link=>'/biz/shareasale/doba/?VERB=EDIT&PROFILE=%PROFILE%',
		source=>'WEBSITE-ALL',
		},
	'DOB'=>{
		use_inventory=>1,
		title=>'DOBA Supplier Interface',
		module=>'DOBA',
		attrib=>'doba:ts',
		stashable=>1,
		validationLogPlease=>1,
		source=>'PRODUCTS-ALL',		
		link=>'/biz/syndication/doba/?VERB=EDIT&PROFILE=%PROFILE%',
		},
	## USER SPECIFIC ONES:
	'IOF'=>{
		title=>'Ioffer.com syndication',
		module=>'IOFFER',
		source=>'WEBSITE-ALL',
		},
	'AMZ'=>{
		title=>'Amazon Seller Central',
		module=>'AMAZON',
		stashable=>1,
		attrib=>'amz:ts',
		source=>'',
		},
	'APA'=>{
		title=>'Amazon Product Ads',
		module=>'AMAZONPA',
		attrib=>'amzpa:ts',
		linkmeta=>'amzpa',
		source=>'WEBSITE-ALL',
      analytics_utm_source=>'AMAZONPA',
      analytics_utm_content_var=>'amzpa:content',
      analytics_utm_campaign_var=>'amzpa:campaign',
		validationLogPlease=>1,
		syndicationOPTIONs=>2+8,
		link=>'/biz/syndication/amazonpa/?VERB=EDIT&PROFILE=%PROFILE%',
		source=>'WEBSITE-ALL',
		},
	'EBY'=>{
		title=>'eBay',
		compatible=>0,
		},
	'MYS'=>{
		title=>'MySimon',
		compatible=>0,
		module=>'MYSIMON',
		attrib=>'mysimon:ts',
      syndicationOPTIONs=>1,	
		navcatMETA=>'MYSIMON_CAT',
		analytics_utm_source=>'MYSIMON',
		analytics_utm_content_var=>'mysimon:content',
		analytics_utm_campaign_var=>'mysimon:campaign',
		link=>'/biz/syndication/mysimon/?VERB=EDIT&PROFILE=%PROFILE%',
		source=>'WEBSITE-ALL',
		},
	'NXT'=>{
		title=>'NexTag',
		compatible=>1,
		module=>'NEXTAG',
		attrib=>'nextag:ts',	
		syndicationOPTIONs=>1,
		linkmeta=>'NEXTAG',
		navcatMETA=>'NEXTAG',
		analytics_utm_content_var=>'nextag:content',
		analytics_utm_campaign_var=>'nextag:campaign',		
		link=>'/biz/syndication/nextag/?VERB=EDIT&PROFILE=%PROFILE%',
		source=>'WEBSITE-ALL',
		},
	'OST'=>{
		title=>'Overstock',
		compatible=>0,
		},
   'HSN'=>{
		use_inventory=>1,
		title=>'HSN.com',
		module=>'HSN',
		attrib=>'hsn:ts',
		stashable=>1,
		expandPOGs=>1,
		validationLogPlease=>1,
		link=>'/biz/syndication/hsn/?VERB=EDIT&PROFILE=%PROFILE%',
		source=>'PRODUCTS-ALL',
      },
   );


%SYNDICATION::DSTCODES = ();
foreach my $dstcode (keys %SYNDICATION::PROVIDERS) {
	$SYNDICATION::DSTCODES{$dstcode} = $SYNDICATION::PROVIDERS{$dstcode}->{'title'};
	}

#%SYNDICATION::DSTCODES = (
#	'AMZ'=>'Amazon',
#	'BUY'=>'Buy.com',
#	'BSS'=>'Buysafe',
#	'JLY'=>'JellyFish',
#	'EBY'=>'eBay',
#	'BZR'=>'Bizrate',
#	'ESS'=>'eBay Store Syndication',
#	'CJ' =>'Commission Junction',
#	'DOB'=>'Doba Supplier Interface',
#	'GOO'=>'GoogleBase / Google Shopping',
#	'GSM'=>'Google Site Map',
#	'MYS'=>'MySimon',
#	'PGR'=>'PriceGrabber',
#	'PRV'=>'Power Reviews',
#	'YST'=>'Yahoo Shopping',
#	'NXT'=>'NexTag',
#	'SHO'=>'Shopping.com',
#	'OST'=>'OverStock',
#	'UPI'=>'U-PIC Shipping Insurance',
#	'EBT'=>'eBates.com',
#	'IOF'=>'Ioffer.com',
#	'IMS'=>'Imshopping.com',	
#	);



##
## a standard validation library for handling most types of standard validation with inheritence issues.
##$SYNDICATION::GOOGLEBASE::ATTRIBUTES = [
##   [ 'gbase:prod_name', 'zoovy:prod_name', { 'required'=>1, 'maxlength'=>70, 'nb'=>1 } ],
##   ];
##
sub validate {
	my ($ATTRIBUTES,$prodref) = @_;

	my $ERROR = undef;
	foreach my $row (@{$ATTRIBUTES}) {
		my ($attrib,$loadfrom,$validation) = @{$row};
		## inherit $attrib from $loadfrom
		if (not defined $prodref->{$attrib}) { 
			$prodref->{$attrib} = $prodref->{$loadfrom}; $attrib = $loadfrom; 
			}
		if (not defined $validation) {
			## undef is a totally valid state for validation.
			}
		elsif (ref($validation) eq 'HASH') {
			foreach my $k (keys %{$validation}) {
				next if (defined $ERROR);
				if (($k eq 'required') && (not defined $prodref->{$attrib})) { 
					$ERROR = "{$attrib}Required field $attrib not set"; 
					}
				elsif (($k eq 'maxlength') && (length($prodref->{$attrib})>$validation->{$k})) {
					$ERROR = "{$attrib}Field $attrib exceeds maximum length of $validation->{$k}";
					}
				elsif (($k eq 'nb') && ($prodref->{$attrib} eq '')) {
					$ERROR = "{$attrib}Field $attrib cannot be blank.";
					}
				}
			}
		else {
			Carp::confess::confess("invalid validation type");
			}
		}
	return($ERROR);
	}



##
##
##
sub excuseMeCouldYouPleaseFix {
	my ($self, $ts, $PID, $attrib, $reason) = @_;

	open F, ">>/tmp/pleasefix.txt";
	print F "$ts\t$PID\t$attrib\t$reason\n";
	close F;
	}



##
## FEED_TYPE
##
sub createBatchJob {
	my ($self,$FEEDTYPE,%options) = @_;

	$FEEDTYPE = uc($FEEDTYPE);
	if ($FEEDTYPE eq 'PRODUCTS') { $FEEDTYPE = 'PRODUCT'; }

	my $bj = undef	;
	if (not defined $bj) {
		}
	elsif ($FEEDTYPE eq 'PRODUCT') {
		## this is cool.
		}
	else {
		$bj = { err=>"Unknown feed type: $FEEDTYPE" };
		}

	if ((not defined $bj) && (not defined $options{'*LU'})) {
		$bj = { err=>"so->createBatchJob requires *LU parameter to be passed as option" };
		}
	
	if (not defined $bj) {
		require BATCHJOB;
	
		my ($GUID) = &BATCHJOB::make_guid();
		$self->set('GUID',$GUID);
		my %VARS = ();
		$VARS{'DST'} = $self->dstcode();
		$VARS{'PROFILE'} = $self->profile();
		$VARS{'FEEDTYPE'} = $FEEDTYPE;
		($bj) = BATCHJOB->new($self->username(),0,
			'GUID'=>$GUID,
			'EXEC'=>'SYNDICATION',
			'%VARS'=>\%VARS,
			'PRT' => $self->prt(),
			'TITLE'=>sprintf("Syndication %s %s",$self->dstcode(),$FEEDTYPE),
			%options);
		if (not defined $bj) { 
			$bj->{'err'} = "Unknown result from so->createBatchJob"; 
			}
		else {
			$self->save();
			}
		print STDERR Dumper($GUID,$bj);
		# VERB=ADD&EXEC=SYNDICATION&DST=PGR&PROFILE=$ns&GUID=$ts	
		}

	return($bj);
	}




sub isBatchJob {
	my ($self) = @_;

	if (not defined $self->{'*PARENT'}) {
		return(0);	# nope, not a batch job
		}
	elsif (ref($self->{'*PARENT'}) eq 'BATCHJOB::SYNDICATION') {
		return(1);
		}
	else {
		return(0);
		}
	return(0);
	}


sub pleaseSirMayIHaveSomeValidations {
	my ($self) = @_;

	my $c = '';
	if ($self->get('.validation_errors')==0) {
		$c = "Product feed contained no validation errors";
		}
	else {
		my $url = sprintf("/biz/setup/private/index.cgi/download.csv?VERB=DOWNLOAD&GUID=%s&FILE=%s",
			$self->get('.validation_log_guid'),
			$self->get('.validation_log_file'));
			
		$c = qq~Product feed contained ~.$self->get('.validation_errors').qq~ errors.<br>
<a href="$url">Download Validation Log</a><br>
<div class="hint">
HINT: The validation log may also be imported as a CSV file to correct the values.
</div>
~;
		}

	return($c);
	}



##
## erefid is the external/marketplace reference id
##
sub resolve_erefid {
	my ($self, $EREFID) = @_;

	my ($udbh) = &DBINFO::db_user_connect($self->username());
	my ($USERNAME) = $self->username();
	my ($MID) = &ZOOVY::resolve_mid($USERNAME);
	my ($TB) = &DBINFO::resolve_orders_tb($self->username());
	my $dstinfo = $SYNDICATION::PROVIDERS{$self->dstcode()};
	if (not defined $dstinfo) {
		Carp::confess("Could not resolve ".$self->dstcode()." in SYNDICATION::PROVIDERS");
		}
	if (not defined $dstinfo->{'attrib'}) {
		Carp::confess($self->dstcode()." does not appear to have it's own special attrib");
		}
	my $bwinfo = $ZOOVY::MKT_BITVAL{ $dstinfo->{'attrib'} };
	if (not defined $bwinfo) {
		Carp::confess($self->dstcode()." attrib $dstinfo->{'attrib'} does not appear in ZOOVY::MKT_BITVAL");
		}

	my $pstmt = "select * from $TB where MID=$MID /* $USERNAME */ and (MKT&$bwinfo->[0])>0 and ORDER_EREFID=".$udbh->quote($EREFID);
	print STDERR $pstmt."\n";
	my $sth = $udbh->prepare($pstmt);
	$sth->execute();
	my ($hashref) = $sth->fetchrow_hashref();
	$sth->finish();
	&DBINFO::db_user_close();

	# print 'RESULT: '.Dumper($hashref);

	return($hashref);
	}


sub xinfo {
	my ($self) = @_;
	
	my @result = ();
	push @result, $SYNDICATION::DSTCODES{$self->{'DSTCODE'}};
	push @result, $self->statustxt();

	return(@result);
	}


##
## increments the ERRCOUNT without saving the object.
##
sub inc_err {
	my ($self) = @_;
	my ($dbh) = &DBINFO::db_user_connect($self->username());
	my ($USERNAME) = $self->username();
	my $pstmt = "update SYNDICATION set ERRCOUNT=ERRCOUNT+1 where /* $USERNAME */ ID=".$self->dbid();
	print STDERR $pstmt."\n";
	$dbh->do($pstmt);
	&DBINFO::db_user_close();
	}


##
## To TIE a syndication object you must pass USERNAME=> PROFILE=> and DSTCODE=>
##		or simply pass THIS=>object
##
sub TIEHASH {
	my ($class, %options) = @_;

	if (defined $options{'THIS'}) { return ($options{'THIS'}); }
	if (not defined $options{'USERNAME'}) { return(undef); }
	if (not defined $options{'PROFILE'}) { return(undef); }
	if (not defined $options{'DSTCODE'}) { return(undef); }
	my ($self) = SYNDICATION->new($options{'USERNAME'},$options{'PROFILE'},$options{'DSTCODE'});
	if (not defined $self->{'_CHANGES'}) { $self->{'_CHANGES'}=0; }
	return($self);
	}

sub FETCH { my ($this,$key) = @_; return($this->get($key)); }
sub STORE { my ($this,$key,$value) = @_; return($this->set($key,$value)); }
sub DELETE { my ($this,$key) = @_; return($this->set($key,undef)); }
# sub FIRSTKEY { my ($this) = @_; }
# sub NEXTKEY { my ($this) = @_; }

sub DESTROY {
	my ($this,$key) = @_;
	if ($this->{'_CHANGES'}==0) {}
	else {
		$this->save();
		undef $this;
		}
	return(undef);
	}



sub pid_attrib {
	my ($self) = @_;

	my ($USERNAME) = $self->username();
	my ($DSTCODE) = $self->dstcode();

	my $p = $SYNDICATION::PROVIDERS{$DSTCODE};
	if (not defined $p) { $p = {}; }
	my $attrib = $p->{'attrib'};
	return($attrib);
	}

##
## returns a hashref of product id's and timestamps which are allowed to syndicate to a marketplace.
##
sub pids_ts {
	my ($self, %options) = @_;

	my ($USERNAME) = $self->username();
	my $attrib = $self->pid_attrib();
	my $result = undef;
	if (defined $attrib) {
		$result = &ZOOVY::syndication_pids_ts($USERNAME,$attrib, %options);
		}

	return($result);
	}



## some constant functions.
sub dbid { return($_[0]->{'ID'}); }
sub username { return($_[0]->{'USERNAME'}); }
sub mid { return(&ZOOVY::resolve_mid($_[0]->username())); }
sub profile { return($_[0]->{'PROFILE'}); }
sub bj { my ($self) = @_; return($self->{'*PARENT'}); }
sub dstcode { return($_[0]->{'DSTCODE'}); }
sub prt { my ($self) = @_; return(&ZOOVY::profile_to_prt($self->username(),$self->profile())); }
sub guid { return($_[0]->{'PRIVATE_FILE_GUID'}); }
sub userdata { my ($self) = @_; return($self->{'%DATA'}); }
sub stash { return($_[0]->{'*STASHES'}); }
sub has_stash { return( ((defined $_[0]->{'*STASHES'}) && (ref($_[0]->{'*STASHES'}) eq 'PRODUCT::STASHES')) ); }
sub msgs { return($_[0]->{'*MSGS'}); }

sub domain { 
	my ($self) = @_;
	require DOMAIN::TOOLS;
	my ($DOMAIN) = &DOMAIN::TOOLS::syndication_domain($self->username(),$self->profile());
	if ($DOMAIN eq '') {
		$DOMAIN = DOMAIN::TOOLS::domain_for_prt($self->username(),$self->prt());
		&ZOOVY::confess($self->username(),
			sprintf("Unknown syndication_domain for profile %s",$self->profile()),
			justkidding=>1);
		}
	return($DOMAIN);
	# return(DOMAIN::TOOLS::domain_for_profile($self->username(),$self->profile());
	#return());
	}



sub transfer_email {
	my ($self,$URL,$FILESARRAY) = @_;

	my ($lm) = $self->msgs();

	my ($ERROR) = ();
	if ($URL =~ /^email:(.*?)$/) {
		my ($EMAIL) = ($1);
		require MIME::Lite;
		my $subj = "Syndication Feed ".$self->dst();
		my $msg = MIME::Lite->new(
				From => "billing\@zoovy.com",
				To=> $EMAIL,
				Subject=>$subj,
				Type=>"multipart/mixed"
				);

		foreach my $f (@{$FILESARRAY}) {
			if (ref($f) eq '') {
				## scalar
			   ### Add parts (each "attach" has same arguments as "new"):
			   $msg->attach(
					# Type=>'text/csv',
					# Data=>$out,
					Path=>"$f",		# filename in the email
					Filename=>"$f",
					Disposition=>"attachment",
			      );
				}
			elsif (ref($f) eq 'HASH') {
				## hashref w/ in+out keys
				# print STDERR "HASHREF IN+OUT PUT FILE=$f UPFILE=$UPFILE\n";
			   ### Add parts (each "attach" has same arguments as "new"):
			   $msg->attach(
					# Type=>'text/csv',
					# Data=>$out,
					Path=>$f->{'in'},		# filename in the email
					Filename=>$f->{'out'},
					Disposition=>"attachment",
			      );
				}
			else {
				$ERROR = "Unknown data type passed in FILESARRAY got:".ref($f);
				}
			}

   	$msg->send();
		$lm->pooshmsg("SUCCESS|+Emailed to $EMAIL");
		}
	else {
		$ERROR = "Unhandled URL format: $URL";
		}
	return($ERROR)
	}



##
## FILES is an array which can contain either scalars or hashrefs
##	scalar: [$FILENAME]	(the input file -- only compatible with single file transfers)
##	hashref: [{'in'=>$FILENAME,'out'=>$UPLOADFILENAME}]
sub transfer_ftp {
	my ($self,$URL,$FILESARRAY) = @_;

	my $ERROR = undef;
	my ($USER,$PASS,$HOST,$PORT,$UPFILE);
	if ($URL =~ /^ftp\:\/\/(.*?):(.*?)\@(.*?)\/(.*?)$/) {
		($USER,$PASS,$HOST,$UPFILE) = ($1,$2,$3,$4);
		$UPFILE = URI::Escape::uri_unescape($UPFILE);
		}
	elsif ($URL eq '') {
		($USER) = $self->get('.ftp_user');
		($PASS) = $self->get('.ftp_pass');
		($HOST) = $self->get('.ftp_server');		
		}
	else {
		$ERROR = "could not determine user credentials for transfer_ftp";
		}

	$USER = URI::Escape::uri_unescape($USER);
	$PASS = URI::Escape::uri_unescape($PASS);
	$HOST = URI::Escape::uri_unescape($HOST);

	$PORT = 21;
	if ($HOST =~ /^(.*?):([\d]+)$/) {
		## found an alternate FTP port number (necessary for buy.com which uses an active ftp proxy)
		$PORT = int($2);
		$HOST = $1;
		}
		
	print STDERR 'DIAGS:'.Dumper({$USER,$PASS,$HOST,$UPFILE});
	my $ftp = ();
	my $rc = '';
	if ($ERROR eq '') {
		require Net::FTP;
		$ftp = Net::FTP->new("$HOST", Port=>$PORT, Debug => 1);
		print STDERR "FTPSERV:[$HOST] FUSER: $USER FPASS: $PASS\n";
		if (not defined $ftp) { $ERROR = "Unknown FTP server $HOST"; }
		}
	if ($ERROR eq '') {
		$rc = $ftp->login($USER,$PASS);	
		print STDERR "RC: $rc\n";
		if ($rc!=1) { $ERROR = 'FTP User/Pass invalid.'; }
		}

	if ($ERROR eq '') {
		## BAD: commission junction does not accept pasv ftp connections.
		# $ftp->pasv();
		
		foreach my $f (@{$FILESARRAY}) {
			$ftp->binary();
			if (ref($f) eq '') {
				## scalar
				print STDERR "SCALAR PUT FILE=$f UPFILE=$UPFILE\n";
				if ($ftp->put($f,$UPFILE)) {
					$self->msgs()->pooshmsg("INFO-FTP|+FTP PUT $UPFILE");
					}
				else {
					$self->msgs()->pooshmsg("ERROR-FTP|+FTP PUT FAILED ON FILE=$UPFILE");
					}
				}
			elsif (ref($f) eq 'HASH') {
				## hashref w/ in+out keys
				print STDERR "HASHREF IN+OUT PUT F->in=$f->{'in'} F->out=$f->{'out'}\n";
				if ($ftp->put($f->{'in'},$f->{'out'})) {
					$self->msgs()->pooshmsg("INFO-FTP|+FTP PUT FILE=$f->{'out'}");
					}
				else {
					$self->msgs()->pooshmsg("ERROR-FTP|+FTP PUT FAILED ON FILE=$f->{'out'}");
					}
				}
			else {
				$ERROR = "Unknown data type passed in FILESARRAY got:".ref($f);
				}
			}
		}

	if ($ERROR eq '') {
		$ftp->quit;
		}
	return($ERROR);
	}


##
## $NS can be a profile, OR #0 #1, #2 to reference partition.
##		  -- most syndications (in the future) will be *per* partition, not per profile/specialty site.
##
## valid options;
##
sub new {
	my ($class, $USERNAME, $NS, $DST, %options) = @_;

	## initialize some sane defaults..
	if (not defined $options{'AUTOCREATE'}) { $options{'AUTOCREATE'}++; }

	if (substr($NS,0,1) eq '#') {
		## we can pass "#1" in the NS to reference the profile for a given partition.
		my $PRT = substr($NS,1);
		$NS = &ZWEBSITE::prt_get_profile($USERNAME,int($PRT));
		}

	if (not defined $USERNAME) {
		warn "requested SYNDICATION object without passing USER[$USERNAME]\n";
		return(undef);
		}
	if (not defined $DST) {
		warn "requested SYNDICATION object without passing DST[$DST]\n";
		return(undef);
		}

	if ($NS eq '') { $NS = 'DEFAULT'; }

	my $dbh = &DBINFO::db_user_connect($USERNAME);
	my $MID = &ZOOVY::resolve_mid($USERNAME);
	my $pstmt = "select * from SYNDICATION where DSTCODE=".$dbh->quote($DST)." and MID=$MID /* $USERNAME */ and PROFILE=".$dbh->quote($NS);
	my $sth = $dbh->prepare($pstmt);
	$sth->execute();
	my $self = {};
	if ($sth->rows()>0) {
		($self) = $sth->fetchrow_hashref();
		}
	elsif (not $options{'AUTOCREATE'}) {
		## don't autocreate - 
		$self = undef;
		}
	else {
		$self->{'DSTCODE'} = $DST;
		$self->{'USERNAME'} = $USERNAME;
		$self->{'PROFILE'} = $NS;
		$self->{'MID'} = $MID;
		$self->{'IS_ACTIVE'} = 0;
		$self->{'CREATED_GMT'} = time();
		$self->{'LASTSAVE_GMT'} = -1;
		$self->{'DIAG_MSG'} = 'No Status Info Available';
		$self->{'ERRCOUNT'} = 0;
		}
	$sth->finish();
	&DBINFO::db_user_close();

	if (defined $options{'*MSGS'}) {
		$self->{'*MSGS'} = $options{'*MSGS'};
		}
	else {
		$self->{'*MSGS'} = LISTING::MSGS->new($USERNAME);
		}

	if (defined $self) {
		if (defined $options{'*BJ'}) {
			$self->{'*PARENT'} = $options{'*BJ'};
			}

		if (not defined $self->{'_CHANGES'}) { $self->{'_CHANGES'}=0; }
		if (substr($self->{'DATA'},0,3) eq '---') {
			$self->{'%DATA'} = YAML::Syck::Load($self->{'DATA'});
			}
		elsif ($self->{'DATA'} eq '') {
			## not initialized!
			}
		else {
			## legacy format:
			die();
			# $self->{'%DATA'} = &SYNDICATION::decodeini($self->{'DATA'});
			}
		bless $self, 'SYNDICATION';
		}


	return($self);
	}



##
## outputs a status message to describe whats going on in a specific syndication
##
sub statustxt {
	my ($self) = @_;

	my $txt = '';
	if (($self->{'LOCK_ID'}>0) && ($self->{'LOCK_GMT'}>0) && ($self->{'LOCK_GMT'}+7200 < time())) {
		$txt = qq~<div class="error">CRASHED! ~.&ZTOOLKIT::pretty_date($self->{'LOCK_GMT'}).qq~</div><div class="hint">Please contact Zoovy Support to resolve this issue.</div>~;
		}
	elsif ($self->{'LASTSAVE_GMT'}==-1) { 
		$txt = 'Not Configured.';
		}
	elsif ($self->{'IS_ACTIVE'}==0) {
		$txt = 'Inactive.';
		}
	elsif ($self->{'DATA'} eq '') {
		$txt = 'Not Configured.';
		}
	

	if ($txt eq '') {
		foreach my $type ('PRODUCTS','INVENTORY','IMAGES','ORDERS','TRACKING','SHIPPING','ACCESSORIES','RELATIONS','PRICING') {
			if ($self->{"$type\_LASTRUN_GMT"}>0) {
				$txt .= "<br>Last $type Update: ".&ZTOOLKIT::pretty_date($self->{"$type\_LASTRUN_GMT"})."\n";
				if ($self->{"$type\_NEXTRUN_GMT"}>0) {
					$txt .= "<br>Next $type Update: ".&ZTOOLKIT::pretty_date($self->{"$type\_NEXTRUN_GMT"})."\n";
					}
				}
			if ($type eq 'PRODUCTS') {
				$txt .= sprintf("<br>Products Sent: %d\n",$self->{"$type\_COUNT"});
				$txt .= sprintf("<br>Product Errors: %d\n",$self->{"$type\_ERRORS"});
				}
			}
			
		if ($self->{'DIAG_MSG'} ne '') {
			$self->{'DIAG_MSG'} =~ s/[\n\r]/<br>/gs;
			$txt .= '<br>Diagnostic Message:<br><div class="hint">'.$self->{'DIAG_MSG'}."</div>";
			}

		}
	if ($txt eq '') {
		$txt = 'Unknown Status'; 
		}

	return($txt);
	}

##
## This is intended to be used only internally to serialize marketplace specific settings
##
#sub encodeini {
#	my ($paramsref) = @_;
#
#	my $txt = "\n";
#	foreach my $k (sort keys %{$paramsref}) {
#		next if ($k eq '');
#		next if (substr($k,0,1) eq '?');
#		$paramsref->{$k} =~ s/[\n\r]+//gs;
#		$txt .= "$k=$paramsref->{$k}\n";
#		}
#	return($txt);
#	}
##
## This is intended to be used only internally to DEserialize marketplace specific settings
##
#sub decodeini {
#	my ($initxt) = @_;
#
#	my %result = ();
#	foreach my $line (split(/\n/,$initxt)) {		
#		my ($k,$v) = split(/=/,$line,2);
#		$result{$k} = $v;
#		}
#	# use Data::Dumper; 
#	# print STDERR "DECODE INI: ".Dumper(\%result);
#	return(\%result);
#	}


##
## Get an attribute from %DATA
##		attrib sets a value in the object itself e.g. _IS_ACTIVE 
##		.attrib sets a value in the data portion of the object
##
sub get {
	my ($self,$attrib) = @_;

	if (substr($attrib,0,1) ne '.') {
		return($self->{$attrib});
		}
	else {
		$attrib = lc(substr($attrib,1));
		return($self->{'%DATA'}->{$attrib});
		}

	return(undef);	
	}

##
## Sets an attribute in %DATA
##		pass .attrib to set marketplace specific settings.
##
sub set {
	my ($self,$attrib,$val) = @_;

	print STDERR "SYNDICATION SETTING [$attrib]=$val\n";
	if (substr($attrib,0,1) ne '.') {
		print STDERR "$attrib [$self->{$attrib}] ne [$val]\n";

		if ($self->{$attrib} ne $val) {
			$self->{$attrib} = $val;
			$self->{'_CHANGES'}++;
			}
		}
	else {
		$attrib = lc(substr($attrib,1));
		if (defined $val) {
			if ($self->{'%DATA'}->{$attrib} ne $val) {			
				$self->{'%DATA'}->{$attrib} = $val;
				$self->{'_CHANGES'}++;
				}
			}
		else {
			delete $self->{'%DATA'}->{$attrib};
			$self->{'_CHANGES'}++;
			}
		}
	
	}

#	if ($cgiv->{'SITE_USER'} eq '') { push @ERRORS, "$MARKET username is required"; }
#	if ($cgiv->{'SITE_PASS'} eq '') { push @ERRORS, "$MARKET password is required"; }
#      &ZWEBSITE::save_website_attrib($USERNAME,'shopster_schedule',$cgiv->{'SCHEDULE'});
#		&ZWEBSITE::save_website_attrib($USERNAME,'shopster',time());


sub filename {
	my ($self,$type) = @_;
	$type = '' unless $type; ## can add '-inventory' suffix to the filename

	my $url = $self->get('.url');
	my ($datafile) = $url;
	if (index($datafile,'/')>=0) {
		$datafile = substr($datafile,rindex($datafile,'/')+1);
		}
	if ($url eq 'null') {
		$datafile = 'data.txt';
		}
	if ($datafile eq '') {
		$datafile = "data.txt";
		}
	$datafile =~ s/[\/\\]+/_/g;
	$datafile = sprintf("%s-%s-%s-%s",$self->profile(),$self->dstcode(),$type,$datafile);
	return($datafile);
	}



##
## url to view file.
##
sub url_to_file {
	my ($self,$type) = @_;

	# filename will be something like: nyciwear-DEFAULT-SHO.out
	my $url = sprintf("http://static.zoovy.com/merchant/%s/%s",$self->username(),$self->filename($type));
	die();
	return($url);
	}

##
## url to the viewer in the private files directory.
##
sub url_to_privatefile {
	my ($self,$type) = @_;
	my $url = "//www.zoovy.com/biz/setup/private/index.cgi?VERB=VIEW&GUID=".$self->guid();
	return($url);
	}


##
## filename e.g. products.xml
##
sub savefile {
	my ($self, $filename, $title, $expires, $buffer) = @_;

	## expires is the number of days into the future
	$expires = int($expires); 
	if ($expires==0) { $expires = 90; }	# default to 90 day expiration

	my $ts = time();
	my $expts = time()+($expires*86400);

#mysql> desc SYNDICATION_LOGS;
#+-------------+------------------+------+-----+---------+-------+
#| Field       | Type             | Null | Key | Default | Extra |
#+-------------+------------------+------+-----+---------+-------+
#| ID          | int(10) unsigned | NO   |     | 0       |       |
#| USERNAME    | varchar(20)      | NO   |     | NULL    |       |
#| MID         | int(10) unsigned | NO   | PRI | 0       |       |
#| DSTCODE     | varchar(3)       | NO   | PRI | NULL    |       |
#| FILENAME    | varchar(25)      | NO   | PRI | NULL    |       |
#| TITLE       | varchar(60)      | NO   |     | NULL    |       |
#| CREATED_GMT | int(11)          | NO   |     | 0       |       |
#| EXPIRES_GMT | int(11)          | NO   |     | 0       |       |
#+-------------+------------------+------+-----+---------+-------+
#8 rows in set (0.03 sec)

	my $dbh = &DBINFO::db_user_connect($self->username());

	my $pstmt = &DBINFO::insert($dbh,'SYNDICATION_FILES',{
		USERNAME=>$self->{'USERNAME'},
		MID=>$self->{'MID'},
		DSTCODE=>$self->{'DSTCODE'},
		FILENAME=>$filename,
		TITLE=>$title,
		CREATED_GMT=>$ts,
		EXPIRES_GMT=>$expts,	
		DATA=>$buffer,
		},debug=>2);

	&DBINFO::db_user_close();	
	return();
	}




##
## this should be called by the syndication engine to determine:
##		the root category,
##		the primary domain
##		a reference to the merchant (profile) namespace
##
sub syn_info {
	my ($self) = @_;

	my $dbh = &DBINFO::db_user_connect($self->username());

	my $DOMAIN = undef;
	my $PROFILE = $self->{'PROFILE'};

	require DOMAIN::TOOLS;
	($DOMAIN) = DOMAIN::TOOLS::syndication_domain($self->{'USERNAME'},$PROFILE);
	$DOMAIN = "www.$DOMAIN";

	my ($nsref) = &ZOOVY::fetchmerchantns_ref($self->{'USERNAME'},$self->{'PROFILE'});

	my $rootcat = $nsref->{'zoovy:site_rootcat'};
	$rootcat =~ s/[\.]+/\./gs;        # sanitize
	$rootcat =~ s/[^a-z0-9\.\_\-]+//gs; # sanitize (this will eventually be part of a filename)

	if ($rootcat eq '') { $rootcat = '.'; }
	print STDERR "ROOT: [$rootcat]\n";
 
	&DBINFO::db_user_close();
	return($DOMAIN,$rootcat,$nsref);
	}


##
## This should be called by a marketplace when it is done syndicating.
##
#sub syn_finish {
#	my ($self, $statustxt, $errcount, $prodcount) = @_;
#
#	if (not defined $errcount) { $errcount = 0; }
#	if (not defined $prodcount){ $prodcount = 0; }
#	return();
#	}


##
## deletes a syndication entry
##
sub nuke {
	my ($self, $ID) = @_;

	# print Dumper($self);
	if (not defined $ID) { $ID = $self->{'ID'}; }
	my $dbh = &DBINFO::db_user_connect($self->username());
	my $pstmt = "delete from SYNDICATION where ID=$ID /* $self->{'USERNAME'} */ limit 1";
	print STDERR $pstmt."\n";
	$dbh->do($pstmt);
	&DBINFO::db_user_close();
	return();
	}

sub deactivate {	
	my ($self,$ID) = @_;

	# print Dumper($self);
	if (not defined $ID) { $ID = $self->{'ID'}; }

	my $dbh = &DBINFO::db_user_connect($self->username());
	my $pstmt = "update SYNDICATION set ACTIVE=0 where ID=$ID /* $self->{'USERNAME'} */ limit 1";
	print STDERR $pstmt."\n";
	$dbh->do($pstmt);
	&DBINFO::db_user_close();
	}


##
## scope: 
##		1 limit by dstcode
##		2 limit by profile
## 
## returns an array of hashrefs
##
sub files {
	my ($self, $scope) = @_;

	my $dbh = &DBINFO::db_user_connect($self->username());
	my ($MID) = $self->{'MID'};
	my @RESULTS = ();

	my $pstmt = "select FILENAME,TITLE,CREATED_GMT from SYNDICATION_FILES where MID=$MID /* $self->{'USERNAME'} */ ";
	if ($scope & 1) { $pstmt .= " and DSTCODE=".$dbh->quote($self->{'DSTCODE'})." "; }
	if ($scope & 2) { $pstmt .= " and PROFILE=".$dbh->quote($self->{'PROFILE'})." "; }
	$pstmt .= " and EXPIRES_GMT<$^T order by ID desc";
	my $sth = $dbh->prepare($pstmt);
	$sth->execute();
	while ( my $hashref = $sth->fetchrow_hashref() ) {
		push @RESULTS, $hashref;
		}
	$sth->finish();
	&DBINFO::db_user_close();
	return(\@RESULTS);
	}




#mysql> desc SYNDICATION_LOGS;
#+-------------+---------------------------+------+-----+---------+----------------+
#| Field       | Type                      | Null | Key | Default | Extra          |
#+-------------+---------------------------+------+-----+---------+----------------+
#| ID          | int(10) unsigned          | NO   | PRI | NULL    | auto_increment |
#| USERNAME    | varchar(20)               | NO   |     | NULL    |                |
#| MID         | int(10) unsigned          | NO   | MUL | 0       |                |
#| PROFILE     | varchar(10)               | NO   |     | NULL    |                |
#| CREATED_GMT | int(10) unsigned          | NO   |     | 0       |                |
#| TYPE        | enum('INFO','WARN','ERR') | YES  |     | INFO    |                |
#| MESSAGE     | varchar(255)              | NO   |     | NULL    |                |
#+-------------+---------------------------+------+-----+---------+----------------+
#7 rows in set (0.00 sec)


##
## TYPES are: 
##		SYS, INFO (anything pertaining to a product), WARN, ERR
##
##  %options are:
##		ts=>
##		pid=>
##		id=>
##
#sub addlog {
#	my ($self, $type, $message, %options) = @_;
#
#	## expires is the number of days into the future
#	if (not defined $options{'ts'}) { $options{'ts'} = time(); }
#	if (not defined $options{'pid'}) { $options{'pid'} = ''; }
#	if (not defined $options{'id'}) { $options{'id'} = 0; }
#
#	my $dbh = &DBINFO::db_user_connect($self->username());
#
#	my $pstmt = &DBINFO::insert($dbh,'SYNDICATION_LOGS',{
#		USERNAME=>$self->{'USERNAME'},
#		MID=>$self->{'MID'},
#		PROFILE=>$self->{'PROFILE'},
#		DSTCODE=>$self->{'DSTCODE'},
#		CREATED_GMT=>$options{'ts'},
#		TYPE=>$type,
#		MESSAGE=>$message,
#		PID=>$options{'pid'},
#		LISTINGID=>$options{'id'},
#		},debug=>1);
#
#	&DBINFO::db_user_close();	
#	return();
#	}

sub addsummary {
	my ($self, $TYPE, %options) = @_;

	my $udbh = &DBINFO::db_user_connect($self->username());

	$TYPE = uc($TYPE);
	if ($TYPE eq 'PRODUCT') { $TYPE='PRODUCTS'; }

	my %p = ();
	$p{'ID'} = 0;
	$p{'USERNAME'}=$self->{'USERNAME'},
	$p{'MID'}=$self->{'MID'},
	$p{'PROFILE'}=$self->{'PROFILE'},
	$p{'DSTCODE'}=$self->{'DSTCODE'},
	$p{'*CREATED'}='now()',
	$p{'FEEDTYPE'} = $TYPE;

	if (($TYPE eq 'NOTE') && ($options{'NOTE'} eq '')) {
		my ($package,$file,$line,$sub,$args) = caller(0);
		$p{'NOTE'} = "NO_NOTE: $package,$file,$line,$sub,$args";
		}
 	elsif ($options{'NOTE'}) {
		$p{'NOTE'} = $options{'NOTE'};
		}
	if ($TYPE ne 'NOTE') {
		$p{'SKU_TOTAL'} = int($options{'SKU_TOTAL'});
		$p{'SKU_VALIDATED'} = int($options{'SKU_VALIDATED'});
		$p{'SKU_TRANSMITTED'} = int($options{'SKU_TRANSMITTED'});
		}

	my $pstmt = &DBINFO::insert($udbh,'SYNDICATION_SUMMARY',\%p,sql=>1);
	print STDERR $pstmt."\n";
	if (not $udbh->do($pstmt)) {
		&ZOOVY::confess($self->{'USERNAME'},"DB error updating syndication status\n$pstmt",justkidding=>1);
		}
	

	&DBINFO::db_user_close();
	return(); 
	}


sub summarylog {
	my ($self) = @_;
   my $logsref = $self->logs();
	
	my $c = '';
   if (defined $logsref) {
      foreach my $logset (@{$logsref}) {
         $c .= "<tr>";
			$c .= "<td>$logset->[0]</td>";
			$c .= "<td>$logset->[1]</td>";
			if ($logset->[1] eq 'NOTE') {
				$c .= "<td colspan=3>$logset->[5]</td>";
				}
			else {
				$c .= "<td>$logset->[2]</td>";
				$c .= "<td>$logset->[3]</td>";
				$c .= "<td>$logset->[4]</td>";
				}
			$c .= "</tr>";
         }
	   }
   else {
      $c = '<tr><td colspan=3><i>there are no logs recorded for this marketplace.</td></tr>';
      }
	return($c);
	}


##
## 
##
sub logs {
	my ($self) = @_;

	my $dbh = &DBINFO::db_user_connect($self->username());
	my ($MID) = $self->mid();
	my ($USERNAME) = $self->username();
	my @RESULTS = ();

	my $pstmt = "select CREATED,FEEDTYPE,SKU_TOTAL,SKU_VALIDATED,SKU_TRANSMITTED,NOTE from SYNDICATION_SUMMARY where MID=$MID /* $USERNAME */ ";
	$pstmt .= " and DSTCODE=".$dbh->quote($self->{'DSTCODE'})." ";
	$pstmt .= " and PROFILE=".$dbh->quote($self->{'PROFILE'})." "; 
	$pstmt .= " order by CREATED desc limit 0,100";
	print STDERR $pstmt."\n";
	my $sth = $dbh->prepare($pstmt);
	$sth->execute();
	while ( my @row = $sth->fetchrow() ) {
		push @RESULTS, \@row;
		}
	$sth->finish();
	&DBINFO::db_user_close();

	if (scalar(@RESULTS)==0) {
		push @RESULTS, [ '', 'NOTE', 0,0,0, 'No logs available.' ];
		}

	return(\@RESULTS);
	}





##
## scope: 
##		1 limit by dstcode
##		2 limit by profile
##		64 return pid 
##		128 return listingid
## 
## returns an array of arrays
##		The secondary array is of TYPE, MESSAGE
#sub logs {
#	my ($self, $bwoptions) = @_;
#
#	if (not defined $bwoptions) { $bwoptions = 3; }
#	my $dbh = &DBINFO::db_user_connect($self->username());
#	my ($MID) = $self->{'MID'};
#	my @RESULTS = ();
#
#	my $pstmt = "select TYPE,MESSAGE,CREATED_GMT ";
#	if ($bwoptions&64) { $pstmt .= ",PID"; }
#	if ($bwoptions&128) { $pstmt .= ",LISTINGID"; }
#	$pstmt .= " from SYNDICATION_LOGS where MID=$MID /* $self->{'USERNAME'} */ ";
#	$pstmt .= " and DSTCODE=".$dbh->quote($self->{'DSTCODE'})." ";
#	$pstmt .= " and PROFILE=".$dbh->quote($self->{'PROFILE'})." "; 
#	$pstmt .= " order by CREATED_GMT desc limit 0,5000";
#	print STDERR $pstmt."\n";
#	my $sth = $dbh->prepare($pstmt);
#	$sth->execute();
#	while ( my @row = $sth->fetchrow() ) {
#		push @RESULTS, \@row;
#		}
#	$sth->finish();
#
#
#
#	&DBINFO::db_user_close();
#
#	if (scalar(@RESULTS)==0) {
#		push @RESULTS, [ 'INFO', 'No logs available.', $^T, '', 0 ];
#		}
#
#	return(\@RESULTS);
#	}




##########################################
##
## silent = pass 1 for silent mode 
##
sub save {
	my ($self,$silent) = @_;

	if (not defined $silent) { $silent = 0; }

	my @ERRORS = ();
	my $dbh = &DBINFO::db_user_connect($self->username());

	if ((not defined $self->{'_CHANGES'}) || ( $self->{'_CHANGES'} == 0)) {
		## no reason to save, nothing changed in the object.
		warn "no reason to save, no changes made";
		}
	elsif (scalar(@ERRORS)>0) {
		## errors occurred, don't save anything.
		}
	else {
		if (not $silent) {
			## don't do a silent save
			$self->addsummary('INFO',NOTE=>'Updated settings');
			}

		if (not defined $self->{'NEEDS_PRODUCTS'}) { $self->{'NEEDS_PRODUCTS'} = 0; }
		if (not defined $self->{'NEEDS_IMAGES'}) { $self->{'NEEDS_IMAGES'} = 0; }
		if (not defined $self->{'NEEDS_INVENTORY'}) { $self->{'NEEDS_INVENTORY'} = 0; }
		if (not defined $self->{'NEEDS_ORDERS'}) { $self->{'NEEDS_ORDERS'} = 0; }
		if (not defined $self->{'NEEDS_TRACKING'}) { $self->{'NEEDS_TRACKING'} = 0; }

		if (not defined $self->{'PRODUCTS_LASTRUN_GMT'}) { $self->{'PRODUCTS_LASTRUN_GMT'} = 0; }
		if (not defined $self->{'INVENTORY_LASTRUN_GMT'}) { $self->{'INVENTORY_LASTRUN_GMT'} = 0; }
		if (not defined $self->{'ORDERS_LASTRUN_GMT'}) { $self->{'ORDERS_LASTRUN_GMT'} = 0; }
		if (not defined $self->{'TRACKING_LASTRUN_GMT'}) { $self->{'TRACKING_LASTRUN_GMT'} = 0; }


		my ($pstmt) = &DBINFO::insert($dbh,'SYNDICATION',{
			'MID'=>$self->{'MID'},
			'DSTCODE'=>$self->{'DSTCODE'},
			'USERNAME'=>$self->{'USERNAME'},
			'PROFILE'=>$self->{'PROFILE'},
			'CREATED_GMT'=>$self->{'CREATED_GMT'},
			'LASTSAVE_GMT'=>time(),
			'IS_ACTIVE'=>$self->{'IS_ACTIVE'},
			'DIAG_MSG'=>$self->{'DIAG_MSG'},
			'ERRCOUNT'=>$self->{'ERRCOUNT'},
			'DATA'=>YAML::Syck::Dump($self->{'%DATA'}),
			'PRODUCTS_COUNT'=>int($self->{'PRODUCTS_COUNT'}),
		NEEDS_PRODUCTS=>$self->{'NEEDS_PRODUCTS'},
		NEEDS_IMAGES=>$self->{'NEEDS_IMAGES'},
		NEEDS_INVENTORY=>$self->{'NEEDS_INVENTORY'},
		NEEDS_ORDERS=>$self->{'NEEDS_ORDERS'},
		NEEDS_TRACKING=>$self->{'NEEDS_TRACKING'},
		PRODUCTS_LASTRUN_GMT=>$self->{'PRODUCTS_LASTRUN_GMT'},
		INVENTORY_LASTRUN_GMT=>$self->{'INVENTORY_LASTRUN_GMT'},
		ORDERS_LASTRUN_GMT=>$self->{'ORDERS_LASTRUN_GMT'},
		TRACKING_LASTRUN_GMT=>$self->{'TRACKING_LASTRUN_GMT'},

			}, key=>['MID','DSTCODE','PROFILE'],debug=>1+2);

		$dbh->do($pstmt);

		$self->{'_CHANGES'}=0;
		}



	&DBINFO::db_user_close();
	return(@ERRORS);
	}





## if we're debugging, this returns the product id (or undef if we're not in debug)
## returns undef for "not debugging"
## returns '' for debug general
## returns pid for blank
sub is_debug { 
	my ($self,$PID) = @_;
	
	if (not $self->{'DEBUG'}) {
		## debug not turned on
		return(undef);
		}
	if ((defined $PID) && ($PID eq $self->{'_TRACEPID'})) {
		return( $self->{'_TRACEPID'} );
		}
	if ($self->{'_TRACEPID'} ne '') {
		return( $self->{'_TRACEPID'} );
		}
	return('');
	};


##
## this is a wrapper around runnow
##		.. but enables debugging in children .. also they behave differently.
##
sub runDebug {
	my ($self, %options) = @_;

	$options{'DEBUG'} = 3;	## never sends a file, but runs full diagnostics.
	$options{'TRACEPID'} =~ s/^[\s]+//gs;	# strip leading whitespace.
	$options{'TRACEPID'} =~ s/[\s]+$//gs;	# strip trailing whitespace.
	$self->{'_TRACEPID'} = $options{'TRACEPID'};

	my ($lm) = $self->msgs();	

	if ($options{'TRACEPID'} ne '') {
		$lm->pooshmsg("INFO|+Starting diagnostics for TracePID[$options{'TRACEPID'}] at ".&ZTOOLKIT::pretty_date(time(),1));
		}
	else {
		$lm->pooshmsg("INFO|+Starting diagnostics for all products at ".&ZTOOLKIT::pretty_date(time(),1));
		}
	$lm->pooshmsg("INFO|+User: ".$self->username()." / Profile: ".$self->profile()." / Partition: ".$self->prt());
		
	$self->runnow(%options);
	$lm->pooshmsg("INFO|+Finished diagnostics for product $options{'TRACEPID'}");	

	my $out = '';
	foreach my $msg (@{$lm->msgs()}) {
		my ($d) = LISTING::MSGS::msg_to_disposition($msg);

		my $type = $d->{'_'};
		my $style = '';
		if ($type eq 'HINT') { 
			$style = 'style="color: green; border: thin dashed;"'; 
			}
		elsif (($type eq 'GOOD') || ($type eq 'SUCCESS')) { 
			$style = 'style="color: blue"'; 
			}
		elsif (($type eq 'FAIL') || ($type eq 'STOP') || ($type eq 'PRODUCT-ERROR')) { 
			$style = 'style="color: red"'; 
			}
		elsif (($type eq 'WARN')) { 
			$style = 'style="color: orange; border: thin dashed;"'; 
			}
		elsif ($type eq 'DEBUG') {
			$style = 'style="color: gray;"';
			}
		elsif ($type eq 'INFO') { 
			$style = 'style="font-size: 8pt; color: CCCCCC;"'; 
			}
		else {
			}
		$out .= "<div $style>$type: $d->{'+'}</div>";
		}

	return($out);	
	}






#############################################################################
##
## Actually builds the file, used by custom feeds, powerreviews, buy.com, buysafe, etc.
##	
##	this is what runnow should have been. :-P
##
##  And I don't like the idea to have single runnow2 for all types of feeds - 
##  products, inventory, ... and all destinations here - too unobvious
## 
## NOTE: $sj is a reference to a syndication job.
##
sub runnow {
	my ($self, %options) = @_;
	
	my $lm = $self->msgs();
	my $sj = $options{'sj'};	## reference to a syndication job (for logging/output)
	my $type = lc($options{'type'});	##
	$self->{'%options'} = \%options;

	if ($type eq '') {
		$options{'type'} = $type;
		warn("type not specified .. assuming product");
		}

	my $DSTCODE = $self->dstcode();
	my $PROFILE = $self->profile();	
	my $PRT = $self->prt();
	my ($DOMAIN,$ROOTCAT,$nsref) = $self->syn_info();

	my ($USERNAME) = $self->username();
	my ($MID) = &ZOOVY::resolve_mid($USERNAME);

	if ($DOMAIN eq '') { $DOMAIN = "$USERNAME.zoovy.com"; }
	my $LINK = "http://$DOMAIN";

	##################################################################
	## Step 0: figure out which data mapping we're going to use and load it.		
	##
	my ($MODULE) = $self->get('.map');
	my $attrib = undef;
	my $headerOnly = 0;

	my $syndicationOPTIONs = 0;	##  need set to skip hidden(1), DO NOT skip LISTS (4)
											## lists are available on the UI
											## 8 = submit parents (even if they don't have inventory)
											
	my $validationLogPlease = 0;

	my %CONFIG = ();
	## attrib			the attribute to filter on ex: market:ts
	## expandPOGs 		eventually this will be a generic syndication property.
	## 		this tells us to expand inventoriable option groups into their SKU's
	## 		for syndication.
	## 		0 = no
	## 		1 = expand into unique options
	## 		2 = do not expand, but merge inventory
	## navcatMETA
	## 	the meta property in NAVCATs which must be populated for inclusion
	## syndicationOPTIONs
	##		
	if ($self->get('.map') ne '') {
		$CONFIG{'module'} = $self->('.map');
		}
	else {
		%CONFIG = %{$SYNDICATION::PROVIDERS{$DSTCODE}};

		## MODULE BEHAVIORS: 
		## 	eventually each module will define these behaviors themselves.
		## 	(or will more likely set them based on user preferences)

		if (defined $SYNDICATION::PROVIDERS{$DSTCODE}->{'syndicationOPTIONs'}) {
			$CONFIG{'syndicationOPTIONs'} =  $SYNDICATION::PROVIDERS{$DSTCODE}->{'syndicationOPTIONs'};
			}
		if (defined $SYNDICATION::PROVIDERS{$DSTCODE}->{'validationLogPlease'}) {
			$validationLogPlease =  $SYNDICATION::PROVIDERS{$DSTCODE}->{'validationLogPlease'};
			}
		$headerOnly = $SYNDICATION::PROVIDERS{$DSTCODE}->{'headerOnly'};
		if (defined $sj) {
			$lm->set_batchjob($sj->bj());
			$sj->bj()->title("Syndication ".$SYNDICATION::PROVIDERS{$DSTCODE}->{'title'}." for $DOMAIN ($PROFILE)");
			$lm->pooshmsg("INFO|+Starting $DOMAIN to $SYNDICATION::PROVIDERS{$DSTCODE}->{'title'}");
			}

		if ($SYNDICATION::PROVIDERS{$DSTCODE}->{'stashable'}) {
			## this module uses a stash so we need to load that from the database.
			require PRODUCT::STASHES;
			$self->{'*STASHES'} = PRODUCT::STASHES->new($USERNAME,$DSTCODE,$PROFILE);
			}
		}

	if (defined $self->get('.feed_options')) {
		## some providers, such as google actually let us set feed_options
		$CONFIG{'syndicationOPTIONs'} = $self->get('.feed_options');
		}

	## check again, since MAP may have been set now.
	if ($CONFIG{'module'} eq '') {
		$lm->pooshmsg("FATAL|+Unknown MAP: $CONFIG{'module'} DST: $DSTCODE");
		}

	## SYNDICATION::REPLACEYOURCELL001
	## SYNDICATION::SLI001
	## SYNDICATION::GEN001
	## SYNDICATION::RAW001
	## STNDICATION::BAMTAR001
	## SYNDICATION::POWERREV
	## SYNDICATION::DOBA
	## SYNDICATION::BUYCOM
	## SYNDICATION::BUYSAFE
	## SYNDICATION::YAHOOSHOP
	my $CLASS = undef;
	my $cl = undef;
	if ($lm->can_proceed()) {
		$CONFIG{'module'} =~ s/[^A-Z0-9]+//g;
		$CLASS = 'SYNDICATION::'.$CONFIG{'module'};

		$cl = Class::Runtime->new( class => $CLASS );
		if ( not $cl->load ) {
			warn "Error in loading class $CLASS\n";
			warn "\n\n", $@, "\n\n";
			$lm->pooshmsg("ISE|+Error loading $CLASS $@");

			# if (defined $sj) { $sj->progress(0,0,"SYNDICATION->load($CLASS) got $ERROR"); }
			}
		}

	my $sm = undef;
	if (not $lm->can_proceed()) {
		## shit happened.
		}
	elsif (($cl->isLoaded) && ($CLASS->can('new'))) {
		## basically this is calling SYNDICATION::DOBA->new() for example
   	$sm = $CLASS->new($self);
		if (ref($sm) ne $CLASS) { $lm->pooshmsg("ISE|+Class $CLASS did not instantiate properly"); }
		}
	else {
		$lm->pooshmsg("ISE|+Cannot call method 'new' on module $CLASS");
		}

	if ((not defined $sm) || (ref($sm) ne $CLASS)) {
		$lm->pooshmsg("ISE|+ERROR UNKNOWN MAP[$CONFIG{'module'}]");
		}

	if (not $lm->can_proceed()) {
		## shit already happened.
		}
	elsif (UNIVERSAL::can($sm, 'preflight')) {
		my ($ERROR) = $sm->preflight();
		if ($ERROR ne '') { 
			$lm->pooshmsg("ERROR|+Preflight - $ERROR"); 
			}
		}
	
	## we use a next here for now .. not good.
	if (not defined $sm) {
		$lm->pooshmsg("ISE|+syndication module CLASS=$CLASS PROFILE=$PROFILE not defined");
		}

	my $TRACEPID = undef;
	if (($lm->can_proceed()) && ($options{'TRACEPID'})) {
		## $TRACEPID is the PID of an item which we're testing (as part of a debug) to figure out what's going wrong.
		$TRACEPID = uc($options{'TRACEPID'});
		$lm->pooshmsg("WARN|debugpid=$TRACEPID|+Tracing $TRACEPID - we're going to focus on that product. 
That means several of the counts such as \"before validation\", \"after validation\" will reflect only 
the trace product(s).  But it's all good, so you got nothing to worry about.");
		}

	########################################################################
	## step 1: create a list of products, and navcats	
	##

	my $duplicates = int($self->get('.duplicates'));			
	# my ($ebaycatref,$storecatref,$ncpretty,$ncprodref) = ();
	my ($maxcount) = $self->get('.maxlistings');
	
	my $SKU_TOTAL = 0;
	my $SKU_VALIDATED = 0;
	my $SKU_TRANSMITTED = 0;

	my $source = $self->get('.source');
	if ($source eq '') { $source = $SYNDICATION::PROVIDERS{$DSTCODE}->{'source'}; }
	if ($source eq '') { $source = 'WEBSITE-META'; }
	if ($source eq 'WEBSITE-EBAY') { $source = 'WEBSITE-META'; }

	if (defined $sj) { 
		$sj->progress(0,0,"Loading from product source:$source"); 
		$lm->pooshmsg("INFO|+Product source $source");
		}

	## NOTE: we need to load $NC now becasue we use it later for paths_by_product
	my ($NC) = NAVCAT->new($USERNAME,root=>$ROOTCAT,PRT=>$PRT);
	my %LAUNCH_PIDS = ();


	if ( not $lm->can_proceed()) {
		## shit happened.
		}
	#elsif (1) {
	#	$LAUNCH_PIDS{'X3-RE'}++;
	#	}
	#elsif (($self->dstcode() eq 'BUY') && ($USERNAME eq 'toynk') && ($options{'type'} eq 'inventory')) {
	#	## toynk sends full inventory to buy.com.
	#	my ($instock,$reserved) = &INVENTORY::load_records($USERNAME,undef);
	#			
	#	}
	elsif ($source eq 'PRODUCTS-ALL') {
		## ALL PRODUCTS
		my ($tsref) = &PRODUCT::build_prodinfo_ts($USERNAME);
		$SKU_TOTAL = scalar(scalar keys %{$tsref});
		$lm->pooshmsg("INFO|+Found $SKU_TOTAL unique products (source: PRODUCTS-ALL)");
		foreach my $pid (keys %{$tsref}) {
			next if ($pid eq '');
			$LAUNCH_PIDS{$pid} = {};
			}
		if (defined $TRACEPID) {
			if (not defined $LAUNCH_PIDS{ $TRACEPID }) {
				$lm->pooshmsg("STOP|+Could not find product $TRACEPID in source=PRODUCTS-ALL");
				}
			}		

		}
	elsif (($source eq 'WEBSITE-META') || ($source eq 'WEBSITE-ALL')) {
		## load from website, with matching META
		# my ($ncpretty,$ncprodref,$ncprodref) = &NAVCAT::FEED::matching_navcats($USERNAME,$CONFIG{'navcatMETA'},$CONFIG{'syndicationOPTIONs'},$ROOTCAT,$self->prt());

		##
		## designed to work with:
		##		FROOGLE_CAT <-- umm.. is 1:22am .. this doesn't exist!
		##		YSHOP_CAT
		##		DEALTIME_CAT
		##		BIZRATE_CAT
		##		NEXTAG
		##		MYSIMON_CAT
		##
		##	OPTIONS (bitwise)
		##		1>>0	1 = skip hidden!
		##		1>>1	2 = check inventory
		##		1>>2	4 = skip lists
		##		1>>3 	8 = send parents (even without inventory)
		if (not defined $ROOTCAT) { $ROOTCAT = '.'; }
		if (not defined $CONFIG{'syndicationOPTIONs'}) { $CONFIG{'syndicationOPTIONs'} = 0; }

		#my %ncpretty = ();			# key=safe, val=breadcrumb of pretty
		#my %ncprodref = ();			# key=product id, val=which safe name it belongs to
		#my %ncmapref = ();			# key=product id, val=the $CONFIG{'navcatMETA'} for that product

		my @paths = sort $NC->paths($ROOTCAT);
		if (scalar(@paths)==0) {
			$lm->pooshmsg("STOP|+There appear to be no categories for root=$ROOTCAT");
			}
		elsif ($self->is_debug()) {
			$lm->poosmsg("INFO|+Found ".(scalar @paths)." total categories on this partition");
			if ($TRACEPID eq '') {
				my %PIDS = ();
				foreach my $safe (@paths) {
					my ($pretty,$children,$products) = $NC->get($safe);
					foreach my $pid (split(/,/,uc($products))) { $PIDS{$pid}++; }
					}
				$lm->pooshmsg("INFO|+Found ".(scalar keys %PIDS)." total products mapped to categories on this partition");
				}

			$lm->pooshmsg("INFO|+Option .. Shall we Skip hidden categories? -- ".((($CONFIG{'syndicationOPTIONs'} & 1)==1)?'Yes':'No'));
			$lm->pooshmsg("INFO|+Option .. Shall we Skip Lists? -- ".((($CONFIG{'syndicationOPTIONs'} & 2)==2)?'Yes':'No'));				
			$lm->pooshmsg("INFO|+Option .. Shall we pre-verify Inventory? -- ".((($CONFIG{'syndicationOPTIONs'} & 4)==4)?'Yes':'No'));				
			$lm->pooshmsg("INFO|+Option .. Shall we send parents without Inventory? -- ".((($CONFIG{'syndicationOPTIONs'} & 8)==8)?'Yes':'No'));				
			$lm->pooshmsg("INFO|+Option .. Shall we Skip Pages? -- Yes");
			if (scalar(@paths)==0) {
				$lm->pooshmsg("WARN|+Found no categories, something went horribly wrong.");
				}
			elsif (defined $TRACEPID) {
				@paths = sort @{$NC->paths_by_product($TRACEPID)};
				$lm->pooshmsg("INFO|+Product \"$TRACEPID\" is in ".(scalar @paths)." website categories on this partition");
				if (scalar(@paths)==0) {
					$lm->pooshmsg("WARN|+Product $TRACEPID is not in any website categories, this will probably be a bumpy ride.");
					}
				}
			}
		

	   foreach my $safe (@paths) {
			my ($pretty, $child, $products, $sortstyle,$metaref) = $NC->get($safe);
			my $skip = 0;
			if ((not defined $CONFIG{'navcatMETA'}) || ($CONFIG{'navcatMETA'} eq '')) {
				## no metakey defined, keep going
				}
			elsif ((($CONFIG{'syndicationOPTIONs'} & 1)==1) && (substr($pretty,0,1) eq '!')) {
				# skip hidden categories.
				$skip =1;
				if (defined $TRACEPID) {
					$lm->pooshmsg("WARN|+Category $safe was skipped because it is hidden.");
					}
				}
	      elsif ((($CONFIG{'syndicationOPTIONs'} & 4)==4) && (substr($safe,0,1) eq '$')) {
				# skip lists.
				$skip =2;
				if (defined $TRACEPID) {
					$lm->pooshmsg("WARN|+Category $safe was skipped because it is a list.");
					}
				}
			elsif (substr($safe,0,1) eq '*') {
				## skip pages.
				$skip =3;
				if (defined $TRACEPID) {
					$lm->pooshmsg("WARN|+Category $safe was skipped because it is a page.");
					}
				}
			elsif (($CONFIG{'navcatMETA'} eq 'EBAYSTORE_CAT') && ($metaref->{$CONFIG{'navcatMETA'}} eq '0')) {
				## NOTE: METAKEY 0 is used by ebay stores to represent OTHER - but is invalid for all else.
				if (defined $TRACEPID) {
					$lm->pooshmsg("INFO|+Category $safe is eligible because EBAYSTORE_CAT is valid.");
					}
				}
			elsif ( 
					(($CONFIG{'module'} eq 'JELLYFISH') || ($CONFIG{'module'} eq 'CJUNCTION')) && 
					(($metaref->{$CONFIG{'navcatMETA'}} eq '- Not Selected -') || ($metaref->{$CONFIG{'navcatMETA'}} eq '0')) 
					) {
				## NOTE: METAKEY 0 or "- Not Selected -" are invalid for JELLYFISH/CJ
				$skip=5;
				if (defined $TRACEPID) {
					$lm->pooshmsg("WARN|+Category $safe was ignored because selected Meta[$CONFIG{'navcatMETA'}] is invalid[$metaref->{$CONFIG{'navcatMETA'}}].");
					}
				}
			elsif ($metaref->{$CONFIG{'navcatMETA'}} eq '') {
				if ($CONFIG{'navcatMETA'} eq 'GOOGLEBASE') {
					## googlebase always gets submitted, even if no product type is set.
					if (defined $TRACEPID) {
						$lm->pooshmsg("INFO|+Category $safe is eligible because googlebase don't require a product type (because we can probably guess it later).");
						}
					}
				else {
					## skip this for "category not set" value
					$skip = 4;
					if (defined $TRACEPID) {
						$lm->pooshmsg("WARN|+Category $safe was ignored because no Meta[$CONFIG{'navcatMETA'}] value was set. (hint: configure syndication categories)");
						}
					}
				}
			else {
				## okay we're going to include this!
				if (defined $TRACEPID) {
					$lm->pooshmsg("INFO|+Category $safe is eligible -- but is it more desirable?");
					}
				}
			next if ($skip);


			my $bc = &NAVCAT::FEED::path_breadcrumb($NC,$safe);
			foreach my $prod (split(/,/,$products)) {
				next if ($prod eq '');
				my $copy = 0;
				if (not defined $LAUNCH_PIDS{$prod}) { 
					$LAUNCH_PIDS{$prod} = {}; 
					}

				if (length($LAUNCH_PIDS{$prod}->{'navcat:safe'}) < length($safe)) {
					## legnth of existign is less than current
					$LAUNCH_PIDS{$prod}->{'navcat:safe'} = $safe;
					$LAUNCH_PIDS{$prod}->{'navcat:bc'} = $bc;
					$LAUNCH_PIDS{$prod}->{'navcat:meta'} = $metaref->{$CONFIG{'navcatMETA'}};

#					print Dumper($metaref,$safe);
#					print "M$metaref->{$CONFIG{'navcatMETA'}} $CONFIG{'navcatMETA'}\n"; die();

					if ($CONFIG{'module'} eq 'EBAYSTORE') {
						$LAUNCH_PIDS{$prod}->{'navcat:ebay_storecat'} = $metaref->{'EBAYSTORE_CAT'};
						$LAUNCH_PIDS{$prod}->{'navcat:ebay_category'} = $metaref->{'EBAY_CAT'};
						$lm->pooshmsg("HINT|+Category $safe was selected to inherit properties from. The length is ".length( $safe )." characters and therefore it seems like the best candidate. (Apparently size does matter)");
						}
					if ((defined $TRACEPID) && ($TRACEPID eq $prod)) {
						$lm->pooshmsg("HINT|+Category $safe was selected to inherit properties from. The length is ".length( $safe )." characters and therefore it seems like the best candidate. (Apparently size does matter)");
						}
					}
				}

			}

		#	print STDERR Dumper( \%LAUNCH_PIDS );
		#	die();

		## Not sure how clients do this.
		if (defined $LAUNCH_PIDS{""}) {
			$lm->pooshmsgs("WARN|+Found null product of '' in LAUNCH_PIDS - removing");
			delete $LAUNCH_PIDS{""};
			}
		##
		## SANITY: at this point LAUNCH_PIDS is *as big* as it's gonna get.
		##				as we go, we'll deflate it a bit by deleting items we shouldn't launch. 
		##


		if (defined $TRACEPID) {
			if (not defined $LAUNCH_PIDS{ $TRACEPID }) {
				## product $TRACEPID wouldn't be launched.
				my @paths = @{$NC->paths_by_product($TRACEPID)};
				if (scalar(@paths)==0) {
					$lm->pooshmsg("STOP|+Could not locate $TRACEPID from TRACEPID in any categories.");
					}
				else {
					$lm->pooshmsg("STOP|+Could not locate $TRACEPID from TRACEPID in qualified navcats .. found in: ".join("\n",@paths));
					}			
				}
			}
		elsif ($self->is_debug()) {
			$lm->pooshmsg("INFO|+After processing categories we have: ".scalar(keys %LAUNCH_PIDS)." products.");
			}
	
		if (scalar(keys %LAUNCH_PIDS)==0) {
			# $ERROR = "There are no products mapped for syndication";
			if ($source eq 'WEBSITE-META') {
				}
			elsif ($source eq 'WEBSITE-ALL') {
				}
			else {
				$lm->pooshmsg("STOP|No products (source:$source)");
				}
			}

		}
	else {
		$lm->pooshmsg("FAIL-FATAL|+UNKNOWN product source \"$source\"");
		}


	$SKU_TOTAL = scalar(keys %LAUNCH_PIDS);
	# print Dumper(\%LAUNCH_PIDS);

	##
	##  check inventory
	##

	if ( ($lm->can_proceed()) && (($CONFIG{'syndicationOPTIONs'} & 2)==2) ) {
		my %IGNORE_INVENTORY = ();
		if (($CONFIG{'syndicationOPTIONs'} & 8)==8) {
			my $result = &ZOOVY::syndication_pids_ts($USERNAME,undef,'parent'=>1);
			foreach my $pid (keys %{$result}) {
				$IGNORE_INVENTORY{$pid}++;
				}
			if ($self->is_debug()) {
				$lm->pooshmsg("INFO|+Found ".(scalar(keys %IGNORE_INVENTORY))." parent products where we will ignore inventory");
				if ($TRACEPID) {
					if ($IGNORE_INVENTORY{$TRACEPID}) {
						$lm->pooshmsg("WARN|+Trace product $TRACEPID IS one of the ignored products.");
						}
					else {
						$lm->pooshmsg("INFO|+Trace product $TRACEPID was NOT found in the list of ignored products (so it better have inventory).");
						}
					}
				}
			}


		my @PIDS = keys %LAUNCH_PIDS;
		my ($skuinvref) = &INVENTORY::fetch_incrementals($USERNAME,\@PIDS,undef,1+8);
		$lm->pooshmsg("INFO|+Inventory returned ".(scalar(keys %{$skuinvref}))." sku records, based on ".(scalar(@PIDS))." product records");

		my ($pidinvref) = &INVENTORY::combine_pogs($skuinvref);
		$lm->pooshmsg("INFO|+Inventory skus were then merged into ".scalar(keys %{$pidinvref})." products");

		foreach my $pid (@PIDS) {
			if ($IGNORE_INVENTORY{$pid}) {
				}
			elsif ($pidinvref->{$pid} <= 0) {
				if ($TRACEPID eq $pid) {  $lm->pooshmsg("WARN|+No inventory for $pid (quantity: $pidinvref->{$pid})"); }
				delete $LAUNCH_PIDS{$pid};
				}
			}
		if ((defined $TRACEPID) && ($TRACEPID ne '')) {
			if (not defined $LAUNCH_PIDS{ $TRACEPID }) {
				## product $TRACEPID wouldn't be launched.
				$lm->pooshmsg("STOP|+Could not locate inventory for $TRACEPID.");
				}
			}
		$lm->pooshmsg("INFO|+After processing inventory we have: ".scalar(keys %LAUNCH_PIDS)." products.");
		}

	########################################################################
	## step 1b: go through and figure out which products are actually allowed to syndicate
	##
	if (($lm->can_proceed()) && (defined $CONFIG{'attrib'})) {
		if (defined $sj) { 
			$sj->progress(0,0,"Finding products with $CONFIG{'attrib'} allowed"); 
			}
		my $allowed = &ZOOVY::syndication_pids_ts($USERNAME,$CONFIG{'attrib'},%options);		
		if ($TRACEPID) {
			$lm->pooshmsg("INFO|+You have ".(scalar keys %{$allowed})." products (account wide) allowed based on $CONFIG{'attrib'} setting.");
			if (not defined $allowed->{$TRACEPID}) {
				$lm->pooshmsg("STOP|+Could not locate $TRACEPID -- was blocked by $CONFIG{'attrib'} field.");
				}
			else {
				$lm->pooshmsg("INFO|+$TRACEPID -- was allowed by $CONFIG{'attrib'} field.");
				$allowed = { $TRACEPID => 1 };
				}
			}

		## go through and delete $LAUNCH_PIDS which aren't allowed to launch.
		foreach my $pid (keys %LAUNCH_PIDS) {
			if (not defined $allowed->{$pid}) {
				delete $LAUNCH_PIDS{$pid};
				}
			}

		$lm->pooshmsg("INFO|+After processing ($CONFIG{'attrib'}) allowed products we have: ".scalar(keys %LAUNCH_PIDS)." products. (TRACE:$TRACEPID)");
		if ((defined $TRACEPID) && ($TRACEPID ne '')) {
			if ($LAUNCH_PIDS{$TRACEPID}) {
				$lm->pooshmsg("INFO|+TracePID[$TRACEPID] is still eligible for syndication.");
				}
			else {
				$lm->pooshmsg("STOP|+Since processing ($CONFIG{'attrib'}) the TracePID[$TRACEPID] is no longer eligible.");
				}
			}
		}
	elsif (not defined $CONFIG{'attrib'}) {
		$lm->pooshmsg("DEBUG|+No attrib:ts (filter) set for this destination, which is a little strange. (you won't be able to fix this).");
		}



	$SKU_VALIDATED = scalar(keys %LAUNCH_PIDS);
	if (($lm->can_proceed()) && (scalar (keys %LAUNCH_PIDS)==0)) {
		$lm->pooshmsg("STOP|+No eligible products after phase 1 validation.");
		}

	if (UNIVERSAL::can($sm,'filterLaunch')) {
		$lm->pooshmsg("INFO|+Before processing filterLaunch we have: ".scalar(keys %LAUNCH_PIDS)." products.");
		$sm->filterLaunch(\%LAUNCH_PIDS);
		$lm->pooshmsg("INFO|+After processing filterLaunch we have: ".scalar(keys %LAUNCH_PIDS)." products.");
		}

 	## step 1c: debugging, just does one product
 	##
 	# $ncprodref = { 'MHP0005' => '' };

	########################################################################
	## step 2: segment these into batches of 25 products for easy processing
	my @batches = ();
	my @new = ();
	my $thisref = \@new;
	my %done = ();
	if ($lm->can_proceed()) {
		if (defined $sj) { 
			$sj->progress(0,0,"Creating product batches"); 
			}
		foreach my $prod (sort keys %LAUNCH_PIDS) {		
			next if (defined $done{$prod});
			push @{$thisref}, $prod;
			if (scalar(@{$thisref})==50) { 
				my @new = ();
				push @batches, $thisref;
				$thisref = \@new;
				}
			$done{$prod}++;
			}
		if (scalar(@{$thisref})>0) { push @batches, $thisref; }
		}


	## run through a validation just to see what would happen.
	$lm->pooshmsg("DEBUG|+Seems we have ".scalar(keys %LAUNCH_PIDS)." products before validation.");

	## quick sanity check:
	if ($CONFIG{'module'} eq 'EBAYSTORE') {
		## since this does updates, it routinely won't have anything to do (and that's not actually an error)
		}
	elsif ($lm->can_proceed()) {
		if (scalar(@batches)==0) {
			$lm->pooshmsg("STOP|+No syndication eligible products found");
			}
		}

	if ($headerOnly) {
		$lm->pooshmsg("DEBUG|+headerOnly option turned on (we don't actually send products)");
		@batches = ();
		}

	########################################################################
	## step 3: parse through the products
	my $FILENAME = "/tmp/$USERNAME-$PROFILE-$DSTCODE.out";
	if (lc($options{'type'}) eq 'inventory') { 
		$FILENAME = "/tmp/$USERNAME-$PROFILE-$DSTCODE-INVENTORY.out"
		}
	## reference to _FILENAME is used by both DOBA/BUYCOM which have their own transfer methods -- DO NOT CHANGE
	$self->{'_FILENAME'} = $FILENAME;

	if ($validationLogPlease) {
		my $TMPDIR = sprintf("/tmp/$DSTCODE-%s-%s-%d",$self->username(),$self->profile(),time());
		if (! -d $TMPDIR) { mkdir($TMPDIR); }
		$self->{'_TMPDIR'} = $TMPDIR;
	
		$self->{'_VALIDATION_ERRORS'} = 0;
		$self->{'_VALIDATION_ERRORS_LOG'} = sprintf("$TMPDIR/$DSTCODE-%s-%s-validation-errors.csv",$self->username(),$self->profile());
		open F, ">$self->{'_VALIDATION_ERRORS_LOG'}";
		print F "# FileCreated=".POSIX::strftime("%Y%m%d %H%M%S",localtime(time()))." (note: you can safely delete this line)\n";
		print F "%CATEGORY,%SKU,%ATTRIB,%ATTRIBVALUE,!VALIDATION_ERROR\n";
		close F;	

		$self->{'%MANAGECATMAP'} = PRODUCT::BATCH::fetchcategories($USERNAME);
		}

	my %PROCESSED_SKUS = ();
	my %WHYNOT = ();
	if ($lm->can_proceed()) {
		open Fzz, ">$FILENAME";
		if (defined $sj) { 
			$sj->progress(0,0,"Creating file header"); 
			}
		my $reccount = 0;
		my $rectotal = scalar(@batches);

		if (lc($options{'type'}) eq 'inventory') {
			print Fzz $sm->header_inventory();
			}
		else {
			print Fzz $sm->header();
			}


		#my $pdbh = &DBINFO::db_products_connect();
		my $udbh = &DBINFO::db_user_connect($USERNAME);
		foreach my $batchref (@batches) {
			## get product data
			$reccount++;
			if (defined $sj) { 
				$sj->progress($reccount,$rectotal,"Loading Products/Inventory Batch"); 
				}
			my ($prodsref) = &ZOOVY::fetchproducts_into_hashref($USERNAME,$batchref);
			my ($invref, $reserveref, $locref) = &INVENTORY::fetch_qty($USERNAME,$batchref);

		 	########################################################################
			## NOTE: at some point we could bypass inventory checks for anything which *DIDNT*
			##			have inventory, or had inventory unlimited.

 			##
 			## PHASE1: preprocess, handle product options
 			##
			my $ALLOWEDATTRIB = $SYNDICATION::PROVIDERS{$DSTCODE}->{'attrib'};
			my $SCHEDULENAME = $self->get('.schedule');
 			foreach my $pid (keys %{$prodsref}) {
				next if ($pid eq '');
 				my $prodref = $prodsref->{$pid};
				my $err = undef;

				## check and make sure product is allowed 
				if ($err) {
					}
				elsif (not defined $ALLOWEDATTRIB) {
					}
				elsif (not defined $prodref->{$ALLOWEDATTRIB}) {
					}
				elsif ($prodref->{$ALLOWEDATTRIB} <= 0) {
					## it's defined, and forbidden
					delete $prodsref->{$pid};
					$err = "Product: $pid was explicitly blocked by $ALLOWEDATTRIB ($prodref->{$ALLOWEDATTRIB})";
					}

				if ($options{'type'} eq 'inventory') {
					## inventory doesn't require a full data feed.
					}
				elsif (($CONFIG{'module'} eq 'POWERREV') || ($CONFIG{'module'} eq 'BUYSAFE') || ($CONFIG{'module'} eq 'BAMTAR001') || ($CONFIG{'module'} eq 'YAHOOSHOP') || ($CONFIG{'module'} eq 'VERUTA') || ($CONFIG{'module'} eq 'NEXTAG')) {
					my ($safe) = @{$NC->paths_by_product($pid)};
					$prodref->{'zoovy:prod_category'} = $NC->pretty_path($safe,delimiter=>' > ');
					}

				if (lc($options{'type'}) eq 'inventory') {
					## inventory doesn't require a full data feed.
					}
				elsif (($CONFIG{'navcatMETA'} ne '') || ($source eq 'WEBSITE-ALL')) {
					## this is where navcat:meta etc. are copied from.
					foreach my $key (keys %{$LAUNCH_PIDS{$pid}}) {
						$prodref->{$key} = $LAUNCH_PIDS{$pid}->{$key};
						}
					}

				if ((not $err) && (UNIVERSAL::can($sm, 'validate'))) {
					## if the syndication module can validate() the product, then let it.
					($err) = $sm->validate($pid,$prodsref->{$pid});
					if ((defined $err) && ($err ne '')) {
						$err = "Product: $pid - Validation $err";
						}
					}

				if (not $err) {
					## create links
	 				$prodref->{'zoovy:link'} = "http://$DOMAIN/product/$pid"; 
					$prodref->{'zoovy:link2'} = "http://$DOMAIN".&SITE::prodref_to_url($USERNAME,$pid,$prodref);

					if (not defined $SYNDICATION::PROVIDERS{$DSTCODE}->{'analytics_utm_source'}) {
						}
					elsif ($nsref->{'analytics:syndication'} eq 'GOOGLE') {
						## CUSTOMER IS USING GOOGLE ANALYTICS SO WE'LL USE THEIR TRACKING STYLE.

						if (not defined $prodref->{ $SYNDICATION::PROVIDERS{$DSTCODE}->{'analytics_utm_campaign_var'} }) {
							## no campaign variable set in product level, so we'll use product id for campaign.
							$prodref->{ $SYNDICATION::PROVIDERS{$DSTCODE}->{'analytics_utm_campaign_var'} } = $pid;
							}
	
						$prodref->{'zoovy:analytics_data'} = sprintf("utm_source=%s&utm_medium=CPC&utm_content=%s&utm_campaign=%s",
							$SYNDICATION::PROVIDERS{$DSTCODE}->{'analytics_utm_source'},
							$prodref->{$SYNDICATION::PROVIDERS{$DSTCODE}->{'analytics_utm_content_var'}},
							$prodref->{$SYNDICATION::PROVIDERS{$DSTCODE}->{'analytics_utm_campaign_var'}}
							);
						}

					if (defined $SYNDICATION::PROVIDERS{$DSTCODE}->{'linkmeta'}) {
						my $meta = $SYNDICATION::PROVIDERS{$DSTCODE}->{'linkmeta'};
						$prodref->{'zoovy:link2'} .= "?meta=$meta&metacpg=$pid";
						if ($prodref->{'zoovy:analytics_data'} ne '') {
							$prodref->{'zoovy:link2'} .= '&'.$prodref->{'zoovy:analytics_data'};
							}
						}
					}


				if (not $err) {
	 				$prodref->{'zoovy:qty_instock'} = $invref->{$pid};
 					if (int($prodref->{'zoovy:inv_enable'}) & 32) { $prodref->{'zoovy:qty_instock'} = 9999; }
					}

 				##
 				## NOTE: eventually this option handling code could be a bit more generic/applicapble to 
 				##			more than just googlebase.				
				my @pogs = ();
				my $HAS_INV_POGS = 0;

				if ($err) {
					## shit happened.
					}
				elsif (not $CONFIG{'expandPOGs'}) {
					## don't care, don't need to expandPOGs anyway.
					## 4/10/09 -- only GOOGLEBASE uses inv product options
					}
 				elsif ($prodref->{'zoovy:pogs'} eq '') {
					## NOTHING TO DO HERE, MOVE ALONG.
					}
				elsif ($prodref->{'zoovy:pogs'} =~ /asm=/) {
					## Skip assemblies, patti - 20070124
					# print STDERR "Skipping $pid - assembly $prodref->{'zoovy:pogs'}\n";	
					$err = "{}Product $pid did not syndicate due to assembly in options. (please disable this item or remove assembly)";
 					}
				else {
					## added "resolve_sogs" to text_to_struct - patti - 20070124
					## temporarily switched back, need to find out about sending 
					##  skus with zero inventory
					@pogs = &POGS::text_to_struct($self->username(),$prodref->{'zoovy:pogs'},1);
					foreach my $pog (@pogs) {
						if ($pog->{'inv'}>0) { $HAS_INV_POGS++; }
						}
					}

				if ((not $err) && ($SCHEDULENAME ne '')) {
					#print Dumper($prodref->{'zoovy:base_price'},$prodref->{'zoovy:orig_price'});
					&WHOLESALE::tweak_product($USERNAME,$SCHEDULENAME,$prodref);
					#print Dumper($prodref->{'zoovy:base_price'},$prodref->{'zoovy:orig_price'});
					#die();
					}
	
	
				if ($err) {
					## shit happened.
					}
				elsif (not $HAS_INV_POGS) {
					}
				elsif ($CONFIG{'expandPOGs'}==2) {
					## expandPOGS == 2
					## this will set the quantity for a single item to the combined total of all options.
					## eventually this should probably be a feed in the syndication options itself.
					my $QTY = 0;
					my $hashref = POGS::build_sku_list($pid,\@pogs,3);
					my @skus = keys %{$hashref};
					foreach my $sku (@skus) {
						$QTY += ($invref->{$sku} - $reserveref->{$sku});
						}
					$prodsref->{$pid}->{'zoovy:qty_instock'} = $QTY;
					}
				elsif ($CONFIG{'expandPOGs'}==1) {
					##  break out inventoriable option groups
					my $resultref = &POGS::build_sku_list($pid,\@pogs,1+2);
					my @skus = keys %{$resultref};
					my ($ONHANDREF,$RESREF,$LOCREF) = &INVENTORY::fetch_qty($USERNAME,\@skus,undef);
 	
					$lm->pooshmsg("DEBUG|+".Dumper($ONHANDREF,$resultref));

					## clone each optsku and add to file.						
					foreach my $optsku (keys %{$resultref}) {
						my $thisprodref = Storable::dclone($prodref);
						# $thisprodref->{'zoovy:qty_instock'} = $invref->{$pid};
						## NOTE: this should probably be synched with TOXML::RENDER line 4936 (zoovy:inv_qty_onhand)
						$thisprodref->{'zoovy:qty_instock'} = $invref->{$optsku};
						if (int($prodref->{'zoovy:inv_enable'}) & 32) { $prodref->{'zoovy:qty_instock'} = 9999; }
						my $prod_name = $thisprodref->{'zoovy:prod_name'};
						&POGS::apply_options($self->username(),$optsku,$thisprodref);

						## todo: set parent.

						## load sku specific settings and put them into the product.
						my ($skuref) = &ZOOVY::deserialize_skuref($thisprodref,$optsku);
						foreach my $k (keys %{$skuref}) {
							$thisprodref->{$k} = $skuref->{$k};
							}

						$thisprodref->{'zoovy:prod_name'} =~ s/\n/ | /g; 	# replace CR/LF's in product name with |
						$prodsref->{$optsku} = $thisprodref;
						}

					#if ($pid eq 'PB-TIP-A5PP') {
					#	print Dumper($pid,\@skus);
					#	die();
					#	}

					delete $prodsref->{$pid};
 					}


				if ($err) {
					## failed validation & preprocessing.
					$lm->pooshmsg("PRODUCT-ERROR|pid=$pid|+$err");
					delete $prodsref->{$pid};
					delete $LAUNCH_PIDS{$pid};
					if (defined $TRACEPID) {
						$lm->pooshmsg("PRODUCT-ERROR|+$err");
						if ($TRACEPID eq $pid) {
							$lm->pooshmsg("STOP|+TracePID:$TRACEPID was not recovered, and was removed from the file due to the previous error.");
							}
						}
					elsif ($self->is_debug()) {
						$WHYNOT{$err}++;
						}

					if ($validationLogPlease) {
						my $attrib = undef;
						if ($err =~ /\{(.*?)\}/) { 
							$attrib = $1;
							}
						else {
							ZOOVY::confess($USERNAME,"ISE: $err is totally not structured right .. please fix the error message",justkidding=>1); 
							}
						# strip error hints:
						$err =~ s/\{(.*?)\}//g;
	
						if ($self->{'_VALIDATION_ERRORS_LOG'} ne '') {
		
							## we can use management categories as "batches"			
							my ($category) = sprintf("%s",$self->{'%MANAGECATMAP'}->{$pid});

							warn "**VALIDATE ERROR/$pid: $err\n";
							open F, ">>$self->{'_VALIDATION_ERRORS_LOG'}";
							my ($csv) = Text::CSV_XS->new();
							my $status = $csv->combine($category,$pid,$attrib,$prodref->{$attrib},$err);		# combine columns into a string
							my $line = $csv->string();							 # get the combined string
							print F "$line\r\n"; # "$pid,$attrib,$prodref->{$attrib},$ERROR\n";
							close F;
							$self->{'_VALIDATION_ERRORS'}++;
							}
						}

					}
				else {
					## passed validation. 
					}

 				}


 
 			## 
 			## PHASE2: generate file
 			##
			if ($lm->can_proceed()) {
				if (scalar(keys %{$prodsref})==0) {
					# note: since we're doing this in batches, we can't actually throw an error.
					# $ERROR = "No eligible products after phase 2 transformation.";
					}
				}
			elsif (defined $sj) { 
				$sj->progress($reccount,$rectotal,"Appending Products to Output"); 
				}

			foreach my $prod (keys %{$prodsref}) {
				next if ($prod eq '');

				if ($CONFIG{'module'} eq 'RAW001') {
					my $i = 0;
					foreach my $path (@{$NC->paths_by_product($prod)}) {
						$i++;
						$prodsref->{$prod}->{"zoovy:navcat$i"} = $path;
						}
					}



				## generate Product feed data line
				$lm->pooshmsg("PRODUCT-SUCCESS|pid=$prod|Added to Output");

				my $line = undef;
				if (lc($options{'type'}) eq 'inventory') {
					$line = $sm->inventory($prod,$prodsref->{$prod});
					}
				else {
					$line = $sm->product($prod,$prodsref->{$prod});	
					}

				if ((defined $line) && ($line ne '') && ($self->has_stash())) {
					## if we have a stash for this syndication, lets update it with the length of the line
					## REMINDER: buycom will *NOT* have a $line set on product feeds since it writes it's own file.
					$self->stash()->set($prod,'ts',$prodsref->{$prod}->{'zoovy:prod_modified_gmt'});
					}

				if ($options{'DEBUG'}&2) {
					## DEBUG=2 blocks actual updates 
					if ($line eq '') {
						$WHYNOT{"Blank line (in-flight data error)"}++;
						}
					else {
						$PROCESSED_SKUS{ $prod } += 1;
						}
					}
				elsif ($line ne '') { 
					$SKU_TRANSMITTED++;
					print Fzz $line;
					$PROCESSED_SKUS{ $prod } += 1; 	## record we processed this so we can ignore in STASH file.
					}
				else {
					$PROCESSED_SKUS{ $prod } = 0;		## sku generated a blank line, but was processed.
					}
				}

			}

		$options{'type'} = lc($options{'type'});
		## hmm.. eventually we should probably do something more elaborate here.

		if ($self->is_debug()) {
			## display reasons we failed.
			$lm->pooshmsg("INFO|+Seems after validation we have ".(scalar(keys %PROCESSED_SKUS))." products.");
			foreach my $lame_reason (sort keys %WHYNOT) {
				my $fucking_lame_reason = $lame_reason;
				$fucking_lame_reason =~ s/\|/ /g;
				$lm->pooshmsg("ERR-SUMMARY|+$fucking_lame_reason ($WHYNOT{$lame_reason})");
				}
			if ($TRACEPID) {
				if ($PROCESSED_SKUS{$TRACEPID}) {
					$lm->pooshmsg("GOOD|+$TRACEPID *WAS* processed and would be included in feed.");
					}
				elsif ($PROCESSED_SKUS{$TRACEPID}) {
					$lm->pooshmsg("FAIL|$TRACEPID *WAS NOT* processed and would be included in feed.");
					}
				}
			}

		############################################################################
		##
		## SANITY: we need to check for products which were *NOT* in the respective feed type.
		##			  some of these might be disallowed even.., but for example on inventory feeds we need
		##			  to update whatever we've sent (even if we're setting that to "it's been deleted") ..
		##			  because silly clients will delete/remove products without taking down from the marketplace.
		##			  $PROCESSED_SKUS{ $SKU } => undef|0|1    where 0 = ignored, 1 = processed. and undef is unknown.
		##


		if (not $self->has_stash()) {
			warn "No %STASH configured - can't delete 'em.";
			}
		elsif ($options{'type'} eq 'product') {	
			## REMOVE/DELETE
			if (UNIVERSAL::can($sm,'PRODUCT_DELETE')) {
				foreach my $SKU (@{$self->stash()->skus()}) {
					next if ((defined $TRACEPID) && ($TRACEPID ne $SKU));
					next if ($PROCESSED_SKUS{ $SKU }>0); 	## check if SKU was handled earlier in file.
					$SKU_TRANSMITTED++;
					my $line = $sm->PRODUCT_DELETE($SKU,$self->stash()->getref($SKU),$PROCESSED_SKUS{$SKU});
					print Fzz $line;
					}				
				}
			else {
				warn "No PRODUCT_DELETE function found.";
				}
			}
		elsif ($options{'type'} eq 'inventory') {
			## REMOVE/DELETE
			if (UNIVERSAL::can($sm,'INVENTORY_DELETE')) {
				foreach my $SKU (@{$self->stash()->skus()}) {
					next if ((defined $TRACEPID) && ($TRACEPID ne $SKU));
					next if ($PROCESSED_SKUS{ $SKU }>0); 	## check if SKU was handled earlier in file.
					$SKU_TRANSMITTED++;
					my ($line) = $sm->INVENTORY_DELETE($SKU,$self->stash()->getref($SKU),$PROCESSED_SKUS{$SKU});
					print Fzz $line;
					}
				}
			else {
				warn "No INVENTORY_DELETE function found.";
				}
			}
		else {
			## unknown type.
			warn "unknown feed type requested.";
			}
	
	
		if (defined $sj) { 
			$sj->progress($reccount,$rectotal,"Appending Footer"); 
			}
		#&DBINFO::db_products_close();
		DBINFO::db_user_close();

		if ($options{'type'} eq 'inventory') {
			print Fzz $sm->footer_inventory();
			}
		else {
			print Fzz $sm->footer();
			}
		close Fzz;
		}

	## agreed to use .ftp_user, .ftp_pass, .doba_user, .doba_pass and hardcode ftp_host for DOBA
	my ($UPFILE) = ('');


	if ($self->get('.url') eq '' and not UNIVERSAL::can($sm, 'upload')) {
		$lm->pooshmsg("FAIL-FATAL|+URL not set. Please check your configuration\n");
		$SKU_TRANSMITTED = 0;
		}	
	my $URL = $self->get('.url');

	if ((defined $sj) && (not $lm->can_proceed())) { 
		$sj->progress(0,0,"Transferring file"); 
		}



	


	if (not $lm->can_proceed()) {
		## shit already happened.		
		}
	elsif ($options{'DEBUG'}&2) {
		$lm->pooshmsg("STOP|+Debug mode - no file was transferred.");
		}
	elsif (UNIVERSAL::can $sm, 'upload') {
		## anytime we've got a proprietary "upload" method in the object, we'll use that.
		my ($ERROR) = $sm->upload($FILENAME);
		if ($ERROR ne '') { 
			$lm->pooshmsg("ERROR|+$ERROR"); $SKU_TRANSMITTED=0; 
			}
		else {
			$lm->pooshmsg("SUCCESS|+received non-error response from upload method");
			}
		}
	elsif ($URL =~ /^site:\/\/(.*?)$/) {
		## SITE (copy to public files directory with a specific filename)
		my ($storefile) = $1;
		$storefile =~ s/[\/\\]+/_/g;

		$storefile = &ZOOVY::resolve_userpath($USERNAME).'/IMAGES/'.$storefile;
		system("/bin/cp $FILENAME $storefile");
		chown 65534, 65534,"$storefile";
		chmod 0666, "$storefile";
		$lm->pooshmsg("SUCCESS|+Stored file $storefile");
		}
	elsif ($URL =~ /^email:(.*?)$/) {
		my ($ERROR) = $self->transfer_email($URL,[{in=>$FILENAME,out=>$FILENAME}]);
		if ($ERROR eq '') {
			$lm->pooshmsg("SUCCESS|+Emailed to $FILENAME");
			}
		else {
			$lm->pooshmsg("FAIL-FATAL|+Email transport error - $ERROR");
			$SKU_TRANSMITTED=0;
			}
		}
	elsif ($URL eq 'null') {
		## do nothing.
		$lm->pooshmsg("DEBUG|Null upload method");
		}
	elsif ($URL =~ /^ftp\:\/\//) {
		## FTP
		my ($ERROR) = $self->transfer_ftp($URL,[$FILENAME]);
		if ($ERROR ne '') { 
			$lm->pooshmsg("ERROR|+$ERROR"); 
			$SKU_TRANSMITTED=0;
			}
		else {
			$lm->pooshmsg("SUCCESS|+Transferred files via FTP"); 
			}
		}
	else {
		$lm->pooshmsg(sprintf("ISE|+Could not understand URL provided. [%s]",$URL));
		$SKU_TRANSMITTED=0;
		}

	if (defined $sj) { 
		$sj->progress(0,0,"Saving local copy"); 
		}



	## write file to the PRIVATE FILES dir/table 
	my $guid = undef;
	require LUSER::FILES;
	my ($lf) = LUSER::FILES->new($USERNAME);
	if ($DSTCODE eq 'DOB') {
		## DOBA saves it's own product feed.
		}
	elsif (defined $lf) {
		my $FILETYPE = 'SYNDICATION';
		if ($DSTCODE eq 'BUY') { $FILETYPE = 'BUYCOM'; }
		if ($DSTCODE eq 'DOB') { $FILETYPE = 'DOBA'; }
		if ($DSTCODE eq 'SRS') { $FILETYPE = 'SEARS'; }

		($guid) = $lf->add(
       	file=>$FILENAME,
         title=>"Syndication Feed $CONFIG{'module'} for $PROFILE Profile",
         type=>$FILETYPE,
         overwrite=>1,
			guid=>$self->{'PRIVATE_FILE_GUID'},
         meta=>{'DSTCODE'=>$DSTCODE,'PROFILE'=>$PROFILE,'TYPE'=>$type},
         );
		## if an insert just occured, a GUID is returned 
		## otherwise, the PRIVATE_FILE_GUID should already be set
		if (defined $guid) { 
			$self->{'PRIVATE_FILE_GUID'} = $guid; 
			}
		}


	########################################################################
	## step 4: copy file to users directory
	
	my %dbupdates = ();
	if ($options{'DEBUG'}&2) {
		warn "Got a good old fashion DEBUG=2 .. no error, no status, no nothing.";
		## no status updates, etc.
		}
	elsif ($lm->has_win()) {
		warn "*********************************** Had Win!\n";
		## was this a first time publication - if so add a TODO acknowledgement.
		if (($options{'type'} eq 'product') && ($self->get('PRODUCTS_LASTRUN_GMT')==0)) {
			TODO::easylog($USERNAME,
				title=>("Product Syndication Feed $DSTCODE ".(($options{'type'} eq '')?"":uc("($options{'type'})"))." Submission"),
				detail=>"Your Feed has been completed.");
			}
		elsif (($options{'type'} eq 'inventory') && ($self->get('INVENTORY_LASTRUN_GMT')==0)) {
			TODO::easylog($USERNAME,
				title=>("Inventory Syndication Feed $DSTCODE ".(($options{'type'} eq '')?"":uc("($options{'type'})"))." Submission"),
				detail=>"Your Feed has been completed.");
			}

		$dbupdates{'ERRCOUNT'} = 0;
		if ($options{'type'} eq 'product') {
			$dbupdates{'PRODUCTS_COUNT'} = (scalar keys %PROCESSED_SKUS);
			$dbupdates{'PRODUCTS_LASTRUN_GMT'} = time();
			$dbupdates{'PRODUCTS_NEXTRUN_GMT'} = time()+80000;
			}
		elsif ($options{'type'} eq 'inventory') {
			$dbupdates{'INVENTORY_COUNT'} = (scalar keys %PROCESSED_SKUS);
			$dbupdates{'INVENTORY_LASTRUN_GMT'} = time();
			$dbupdates{'INVENTORY_NEXTRUN_GMT'} = time()+(3600*2);
			}
		else {
			ZOOVY::confess($USERNAME,"Syndication error (unknown type: $options{'type'}).",justkidding=>1);
			}

		$dbupdates{'DIAG_MSG'} = sprintf("Last Action: %s at %s\n",$options{'type'},&ZTOOLKIT::pretty_date(time(),2)).
			(($dbupdates{'PRODUCTS_COUNT'}>0)?sprintf("Products %d at %s\n",$dbupdates{'PRODUCTS_COUNT'},&ZTOOLKIT::pretty_date($dbupdates{'PRODUCTS_LASTRUN_GMT'},2)):'').
			(($dbupdates{'INVENTORY_COUNT'}>0)?sprintf("Inventory %d at %s\n",$dbupdates{'INVENTORY_COUNT'},&ZTOOLKIT::pretty_date($dbupdates{'INVENTORY_LASTRUN_GMT'},2)):'');
		$lm->pooshmsg("INFO|+$dbupdates{'DIAG_MSG'}");

		$self->addsummary($options{'type'},
			SKU_TOTAL=>$SKU_TOTAL,
			SKU_VALIDATED=>$SKU_VALIDATED,
			SKU_TRANSMITTED=>$SKU_TRANSMITTED,
			);
			
		}
	elsif (my $iseref = $lm->had('ISE')) {
		warn "*********************************** Had ISE!\n";
		print Dumper($iseref);
		require TODO;
		my ($t) = TODO->new($USERNAME,writeonly=>1);
		if (defined $t) {
			$t->add(
				title=>$iseref->{'+'},"Syndication Internal-Error: $DSTCODE",
				link=>"syndication:$DSTCODE",
				class=>"ERROR",
				detail=>sprintf("%s",$iseref->{'+'}),
				);
			}
		$self->addsummary("NOTE",NOTE=>"ERROR:Disabled syndication due to ISE: $iseref->{'+'}");
		$dbupdates{'IS_ACTIVE'} = 0;
		}
	elsif (my $stopref = $lm->had('STOP')) {
		## not sure why we'd get here.		
		warn "*********************************** Had STOP!\n";
		$self->addsummary("NOTE",NOTE=>"Received STOP instruction: $stopref->{'+'}");
		}
	else {
		# print Dumper($self);
		my $whatsup = $lm->whatsup();
		warn "*********************************** Had OTHER!\n";
		my $PROFILE = $self->profile();
		my $DSTTITLE = $SYNDICATION::PROVIDERS{$DSTCODE}->{'title'};

		my $DIAG_MSG = sprintf("%s:%s",$whatsup->{'_'},$whatsup->{'+'});
		$dbupdates{'DIAG_MSG'} = $DIAG_MSG;
		open F, ">/tmp/syndication-dump-$DSTCODE-$USERNAME-$PROFILE";
		print F Dumper($lm);
		close F;

		my $link = $SYNDICATION::PROVIDERS{$DSTCODE}->{'link'};
		if (defined $link) { $link =~ s/%PROFILE%/$PROFILE/; }
		TODO::easylog($USERNAME,
			title=>sprintf("%s.%s $DIAG_MSG",$self->dstcode(),$self->profile()),
			detail=>"The following critical error(s) were encountered:\n\n$DIAG_MSG",
			link=>$link,
			);
		$self->addsummary("NOTE",NOTE=>$DIAG_MSG);
		}

	if (scalar( keys %dbupdates )>0) {
		## copy dbupdates into current object.
		foreach my $k (keys %dbupdates) { $self->{$k} = $dbupdates{$k}; }
		my ($udbh) = &DBINFO::db_user_connect($self->username());
		$dbupdates{'MID'} = $self->mid();
		$dbupdates{'ID'} = $self->dbid();
		$dbupdates{'LOCK_ID'} = 0;
		$dbupdates{'LOCK_GMT'} = 0;
		my ($pstmt) = &DBINFO::insert($udbh,'SYNDICATION',\%dbupdates,key=>['MID','ID'],sql=>1);
		print $pstmt."\n";
		$udbh->do($pstmt);
		print STDERR $pstmt."\n";
		&DBINFO::db_user_close();
		}

	if ($self->has_stash()) {
		$self->stash()->sync();
		}

	if ($validationLogPlease) {
		my ($filename) = substr($self->{'_VALIDATION_ERRORS_LOG'},rindex($self->{'_VALIDATION_ERRORS_LOG'},'/')+1);
		require LUSER::FILES;
		my ($lf) = LUSER::FILES->new($self->username());
		my $FILETYPE = 'SYNDICATION';
		if ($DSTCODE eq 'BUY') { $FILETYPE = 'BUYCOM'; }
		if ($DSTCODE eq 'DOB') { $FILETYPE = 'DOBA'; }
		if ($DSTCODE eq 'SRS') { $FILETYPE = 'SEARS'; }

		my ($fileguid) = $lf->add(
			file=>"$self->{'_VALIDATION_ERRORS_LOG'}",
			meta=>{type=>"VALIDATION"},
			title=>$filename,
			unlink=>1,
			overwite=>1,
			guid=>substr($filename,0,32),
			type=>$FILETYPE,
			expires_gmt=>time()+(86400*30),
			);
		$self->set('.validation_errors',$self->{'_VALIDATION_ERRORS'});
		$self->set('.validation_log_guid',substr($fileguid,0,32));
		$self->set('.validation_log_file',$filename);
		}


	if (defined $sj) { 
		$sj->progress(0,0,"Finished Syndication"); 
		}

	# print Dumper($self); die();
	}




sub runnow_inventory {
	my ($self) = @_;
	return($self->runnow2(undef,'inventory'));
	}


1;
